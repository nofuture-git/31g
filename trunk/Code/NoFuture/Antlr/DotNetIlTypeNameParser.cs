//------------------------------------------------------------------------------
// <auto-generated>
//     This code was generated by a tool.
//     ANTLR Version: 4.6.4
//
//     Changes to this file may cause incorrect behavior and will be lost if
//     the code is regenerated.
// </auto-generated>
//------------------------------------------------------------------------------

// Generated from C:\Projects\31g\trunk\Code\NoFuture\Antlr\Grammers\DotNetIlTypeName.g4 by ANTLR 4.6.4

// Unreachable code detected
#pragma warning disable 0162
// The variable '...' is assigned but its value is never used
#pragma warning disable 0219
// Missing XML comment for publicly visible type or member '...'
#pragma warning disable 1591
// Ambiguous reference in cref attribute
#pragma warning disable 419

namespace NoFuture.Antlr.Grammers {
using Antlr4.Runtime;
using Antlr4.Runtime.Atn;
using Antlr4.Runtime.Misc;
using Antlr4.Runtime.Tree;
using System.Collections.Generic;
using DFA = Antlr4.Runtime.Dfa.DFA;

[System.CodeDom.Compiler.GeneratedCode("ANTLR", "4.6.4")]
[System.CLSCompliant(false)]
public partial class DotNetIlTypeNameParser : Parser {
	public const int
		T__0=1, T__1=2, T__2=3, T__3=4, T__4=5, T__5=6, T__6=7, GENERIC_COUNTER=8, 
		FOUR_SET_VER=9, VERSION=10, CULTURE=11, PUBLIC_KEY_TOKEN=12, PROCESSOR_ARCHITECTURE=13, 
		HEX_VALUE=14, CHIP_SETS=15, IDENTIFIER=16, ID_SEPARATOR=17, NL=18;
	public const int
		RULE_utPrius = 0, RULE_dotNetGenericName = 1, RULE_dotNetGenericArg = 2, 
		RULE_dotNetAsmTypeName = 3, RULE_dotNetAsmName = 4, RULE_dotNetName = 5, 
		RULE_asmVersion = 6, RULE_asmCulture = 7, RULE_asmPubToken = 8, RULE_asmProArch = 9, 
		RULE_tokenValue = 10;
	public static readonly string[] ruleNames = {
		"utPrius", "dotNetGenericName", "dotNetGenericArg", "dotNetAsmTypeName", 
		"dotNetAsmName", "dotNetName", "asmVersion", "asmCulture", "asmPubToken", 
		"asmProArch", "tokenValue"
	};

	private static readonly string[] _LiteralNames = {
		null, "'['", "','", "']'", "', '", "'='", "'=neutral'", "'null'", null, 
		null, "'Version'", "'Culture'", "'PublicKeyToken'"
	};
	private static readonly string[] _SymbolicNames = {
		null, null, null, null, null, null, null, null, "GENERIC_COUNTER", "FOUR_SET_VER", 
		"VERSION", "CULTURE", "PUBLIC_KEY_TOKEN", "PROCESSOR_ARCHITECTURE", "HEX_VALUE", 
		"CHIP_SETS", "IDENTIFIER", "ID_SEPARATOR", "NL"
	};
	public static readonly IVocabulary DefaultVocabulary = new Vocabulary(_LiteralNames, _SymbolicNames);

	[System.Obsolete("Use Vocabulary instead.")]
	public static readonly string[] tokenNames = GenerateTokenNames(DefaultVocabulary, _SymbolicNames.Length);

	private static string[] GenerateTokenNames(IVocabulary vocabulary, int length) {
		string[] tokenNames = new string[length];
		for (int i = 0; i < tokenNames.Length; i++) {
			tokenNames[i] = vocabulary.GetLiteralName(i);
			if (tokenNames[i] == null) {
				tokenNames[i] = vocabulary.GetSymbolicName(i);
			}

			if (tokenNames[i] == null) {
				tokenNames[i] = "<INVALID>";
			}
		}

		return tokenNames;
	}

	[System.Obsolete("Use IRecognizer.Vocabulary instead.")]
	public override string[] TokenNames
	{
		get
		{
			return tokenNames;
		}
	}

	[NotNull]
	public override IVocabulary Vocabulary
	{
		get
		{
			return DefaultVocabulary;
		}
	}

	public override string GrammarFileName { get { return "DotNetIlTypeName.g4"; } }

	public override string[] RuleNames { get { return ruleNames; } }

	public override string SerializedAtn { get { return _serializedATN; } }

	public DotNetIlTypeNameParser(ITokenStream input)
		: base(input)
	{
		_interp = new ParserATNSimulator(this,_ATN);
	}
	public partial class UtPriusContext : ParserRuleContext {
		public DotNetGenericNameContext dotNetGenericName() {
			return GetRuleContext<DotNetGenericNameContext>(0);
		}
		public DotNetAsmTypeNameContext dotNetAsmTypeName() {
			return GetRuleContext<DotNetAsmTypeNameContext>(0);
		}
		public DotNetAsmNameContext dotNetAsmName() {
			return GetRuleContext<DotNetAsmNameContext>(0);
		}
		public DotNetNameContext dotNetName() {
			return GetRuleContext<DotNetNameContext>(0);
		}
		public UtPriusContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_utPrius; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterUtPrius(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitUtPrius(this);
		}
	}

	[RuleVersion(0)]
	public UtPriusContext utPrius() {
		UtPriusContext _localctx = new UtPriusContext(_ctx, State);
		EnterRule(_localctx, 0, RULE_utPrius);
		try {
			State = 26;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,0,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 22; dotNetGenericName();
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 23; dotNetAsmTypeName();
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 24; dotNetAsmName();
				}
				break;

			case 4:
				EnterOuterAlt(_localctx, 4);
				{
				State = 25; dotNetName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotNetGenericNameContext : ParserRuleContext {
		public DotNetNameContext dotNetName() {
			return GetRuleContext<DotNetNameContext>(0);
		}
		public ITerminalNode GENERIC_COUNTER() { return GetToken(DotNetIlTypeNameParser.GENERIC_COUNTER, 0); }
		public DotNetGenericArgContext[] dotNetGenericArg() {
			return GetRuleContexts<DotNetGenericArgContext>();
		}
		public DotNetGenericArgContext dotNetGenericArg(int i) {
			return GetRuleContext<DotNetGenericArgContext>(i);
		}
		public DotNetAsmNameContext dotNetAsmName() {
			return GetRuleContext<DotNetAsmNameContext>(0);
		}
		public DotNetGenericNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotNetGenericName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterDotNetGenericName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitDotNetGenericName(this);
		}
	}

	[RuleVersion(0)]
	public DotNetGenericNameContext dotNetGenericName() {
		DotNetGenericNameContext _localctx = new DotNetGenericNameContext(_ctx, State);
		EnterRule(_localctx, 2, RULE_dotNetGenericName);
		int _la;
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 28; dotNetName();
			State = 29; Match(GENERIC_COUNTER);
			State = 41;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==T__0) {
				{
				State = 30; Match(T__0);
				State = 31; dotNetGenericArg();
				State = 36;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,1,_ctx);
				while ( _alt!=1 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
					if ( _alt==1+1 ) {
						{
						{
						State = 32; Match(T__1);
						State = 33; dotNetGenericArg();
						}
						} 
					}
					State = 38;
					_errHandler.Sync(this);
					_alt = Interpreter.AdaptivePredict(_input,1,_ctx);
				}
				State = 39; Match(T__2);
				}
			}

			State = 45;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==T__3) {
				{
				State = 43; Match(T__3);
				State = 44; dotNetAsmName();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotNetGenericArgContext : ParserRuleContext {
		public DotNetGenericNameContext dotNetGenericName() {
			return GetRuleContext<DotNetGenericNameContext>(0);
		}
		public DotNetAsmTypeNameContext dotNetAsmTypeName() {
			return GetRuleContext<DotNetAsmTypeNameContext>(0);
		}
		public DotNetNameContext dotNetName() {
			return GetRuleContext<DotNetNameContext>(0);
		}
		public DotNetGenericArgContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotNetGenericArg; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterDotNetGenericArg(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitDotNetGenericArg(this);
		}
	}

	[RuleVersion(0)]
	public DotNetGenericArgContext dotNetGenericArg() {
		DotNetGenericArgContext _localctx = new DotNetGenericArgContext(_ctx, State);
		EnterRule(_localctx, 4, RULE_dotNetGenericArg);
		try {
			State = 56;
			_errHandler.Sync(this);
			switch ( Interpreter.AdaptivePredict(_input,4,_ctx) ) {
			case 1:
				EnterOuterAlt(_localctx, 1);
				{
				State = 47; Match(T__0);
				State = 48; dotNetGenericName();
				State = 49; Match(T__2);
				}
				break;

			case 2:
				EnterOuterAlt(_localctx, 2);
				{
				State = 51; Match(T__0);
				State = 52; dotNetAsmTypeName();
				State = 53; Match(T__2);
				}
				break;

			case 3:
				EnterOuterAlt(_localctx, 3);
				{
				State = 55; dotNetName();
				}
				break;
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotNetAsmTypeNameContext : ParserRuleContext {
		public DotNetNameContext dotNetName() {
			return GetRuleContext<DotNetNameContext>(0);
		}
		public DotNetAsmNameContext dotNetAsmName() {
			return GetRuleContext<DotNetAsmNameContext>(0);
		}
		public DotNetAsmTypeNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotNetAsmTypeName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterDotNetAsmTypeName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitDotNetAsmTypeName(this);
		}
	}

	[RuleVersion(0)]
	public DotNetAsmTypeNameContext dotNetAsmTypeName() {
		DotNetAsmTypeNameContext _localctx = new DotNetAsmTypeNameContext(_ctx, State);
		EnterRule(_localctx, 6, RULE_dotNetAsmTypeName);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 58; dotNetName();
			State = 59; Match(T__3);
			State = 60; dotNetAsmName();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotNetAsmNameContext : ParserRuleContext {
		public DotNetNameContext dotNetName() {
			return GetRuleContext<DotNetNameContext>(0);
		}
		public AsmVersionContext asmVersion() {
			return GetRuleContext<AsmVersionContext>(0);
		}
		public AsmCultureContext asmCulture() {
			return GetRuleContext<AsmCultureContext>(0);
		}
		public AsmPubTokenContext asmPubToken() {
			return GetRuleContext<AsmPubTokenContext>(0);
		}
		public AsmProArchContext asmProArch() {
			return GetRuleContext<AsmProArchContext>(0);
		}
		public DotNetAsmNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotNetAsmName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterDotNetAsmName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitDotNetAsmName(this);
		}
	}

	[RuleVersion(0)]
	public DotNetAsmNameContext dotNetAsmName() {
		DotNetAsmNameContext _localctx = new DotNetAsmNameContext(_ctx, State);
		EnterRule(_localctx, 8, RULE_dotNetAsmName);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 62; dotNetName();
			State = 63; Match(T__3);
			State = 64; asmVersion();
			State = 65; Match(T__3);
			State = 66; asmCulture();
			State = 67; Match(T__3);
			State = 68; asmPubToken();
			State = 71;
			_errHandler.Sync(this);
			_la = _input.La(1);
			if (_la==T__3) {
				{
				State = 69; Match(T__3);
				State = 70; asmProArch();
				}
			}

			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class DotNetNameContext : ParserRuleContext {
		public ITerminalNode[] IDENTIFIER() { return GetTokens(DotNetIlTypeNameParser.IDENTIFIER); }
		public ITerminalNode IDENTIFIER(int i) {
			return GetToken(DotNetIlTypeNameParser.IDENTIFIER, i);
		}
		public ITerminalNode[] ID_SEPARATOR() { return GetTokens(DotNetIlTypeNameParser.ID_SEPARATOR); }
		public ITerminalNode ID_SEPARATOR(int i) {
			return GetToken(DotNetIlTypeNameParser.ID_SEPARATOR, i);
		}
		public DotNetNameContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_dotNetName; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterDotNetName(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitDotNetName(this);
		}
	}

	[RuleVersion(0)]
	public DotNetNameContext dotNetName() {
		DotNetNameContext _localctx = new DotNetNameContext(_ctx, State);
		EnterRule(_localctx, 10, RULE_dotNetName);
		try {
			int _alt;
			EnterOuterAlt(_localctx, 1);
			{
			State = 73; Match(IDENTIFIER);
			State = 78;
			_errHandler.Sync(this);
			_alt = Interpreter.AdaptivePredict(_input,6,_ctx);
			while ( _alt!=1 && _alt!=global::Antlr4.Runtime.Atn.ATN.InvalidAltNumber ) {
				if ( _alt==1+1 ) {
					{
					{
					State = 74; Match(ID_SEPARATOR);
					State = 75; Match(IDENTIFIER);
					}
					} 
				}
				State = 80;
				_errHandler.Sync(this);
				_alt = Interpreter.AdaptivePredict(_input,6,_ctx);
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsmVersionContext : ParserRuleContext {
		public ITerminalNode VERSION() { return GetToken(DotNetIlTypeNameParser.VERSION, 0); }
		public ITerminalNode FOUR_SET_VER() { return GetToken(DotNetIlTypeNameParser.FOUR_SET_VER, 0); }
		public AsmVersionContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asmVersion; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterAsmVersion(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitAsmVersion(this);
		}
	}

	[RuleVersion(0)]
	public AsmVersionContext asmVersion() {
		AsmVersionContext _localctx = new AsmVersionContext(_ctx, State);
		EnterRule(_localctx, 12, RULE_asmVersion);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 81; Match(VERSION);
			State = 82; Match(T__4);
			State = 83; Match(FOUR_SET_VER);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsmCultureContext : ParserRuleContext {
		public ITerminalNode CULTURE() { return GetToken(DotNetIlTypeNameParser.CULTURE, 0); }
		public AsmCultureContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asmCulture; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterAsmCulture(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitAsmCulture(this);
		}
	}

	[RuleVersion(0)]
	public AsmCultureContext asmCulture() {
		AsmCultureContext _localctx = new AsmCultureContext(_ctx, State);
		EnterRule(_localctx, 14, RULE_asmCulture);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 85; Match(CULTURE);
			State = 86; Match(T__5);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsmPubTokenContext : ParserRuleContext {
		public ITerminalNode PUBLIC_KEY_TOKEN() { return GetToken(DotNetIlTypeNameParser.PUBLIC_KEY_TOKEN, 0); }
		public TokenValueContext tokenValue() {
			return GetRuleContext<TokenValueContext>(0);
		}
		public AsmPubTokenContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asmPubToken; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterAsmPubToken(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitAsmPubToken(this);
		}
	}

	[RuleVersion(0)]
	public AsmPubTokenContext asmPubToken() {
		AsmPubTokenContext _localctx = new AsmPubTokenContext(_ctx, State);
		EnterRule(_localctx, 16, RULE_asmPubToken);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 88; Match(PUBLIC_KEY_TOKEN);
			State = 89; Match(T__4);
			State = 90; tokenValue();
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class AsmProArchContext : ParserRuleContext {
		public ITerminalNode PROCESSOR_ARCHITECTURE() { return GetToken(DotNetIlTypeNameParser.PROCESSOR_ARCHITECTURE, 0); }
		public ITerminalNode CHIP_SETS() { return GetToken(DotNetIlTypeNameParser.CHIP_SETS, 0); }
		public AsmProArchContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_asmProArch; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterAsmProArch(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitAsmProArch(this);
		}
	}

	[RuleVersion(0)]
	public AsmProArchContext asmProArch() {
		AsmProArchContext _localctx = new AsmProArchContext(_ctx, State);
		EnterRule(_localctx, 18, RULE_asmProArch);
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 92; Match(PROCESSOR_ARCHITECTURE);
			State = 93; Match(T__4);
			State = 94; Match(CHIP_SETS);
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public partial class TokenValueContext : ParserRuleContext {
		public ITerminalNode HEX_VALUE() { return GetToken(DotNetIlTypeNameParser.HEX_VALUE, 0); }
		public TokenValueContext(ParserRuleContext parent, int invokingState)
			: base(parent, invokingState)
		{
		}
		public override int RuleIndex { get { return RULE_tokenValue; } }
		public override void EnterRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.EnterTokenValue(this);
		}
		public override void ExitRule(IParseTreeListener listener) {
			IDotNetIlTypeNameListener typedListener = listener as IDotNetIlTypeNameListener;
			if (typedListener != null) typedListener.ExitTokenValue(this);
		}
	}

	[RuleVersion(0)]
	public TokenValueContext tokenValue() {
		TokenValueContext _localctx = new TokenValueContext(_ctx, State);
		EnterRule(_localctx, 20, RULE_tokenValue);
		int _la;
		try {
			EnterOuterAlt(_localctx, 1);
			{
			State = 96;
			_la = _input.La(1);
			if ( !(_la==T__6 || _la==HEX_VALUE) ) {
			_errHandler.RecoverInline(this);
			} else {
				if (_input.La(1) == TokenConstants.Eof) {
					matchedEOF = true;
				}

				_errHandler.ReportMatch(this);
				Consume();
			}
			}
		}
		catch (RecognitionException re) {
			_localctx.exception = re;
			_errHandler.ReportError(this, re);
			_errHandler.Recover(this, re);
		}
		finally {
			ExitRule();
		}
		return _localctx;
	}

	public static readonly string _serializedATN =
		"\x3\xAF6F\x8320\x479D\xB75C\x4880\x1605\x191C\xAB37\x3\x14\x65\x4\x2\t"+
		"\x2\x4\x3\t\x3\x4\x4\t\x4\x4\x5\t\x5\x4\x6\t\x6\x4\a\t\a\x4\b\t\b\x4\t"+
		"\t\t\x4\n\t\n\x4\v\t\v\x4\f\t\f\x3\x2\x3\x2\x3\x2\x3\x2\x5\x2\x1D\n\x2"+
		"\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\x3\a\x3%\n\x3\f\x3\xE\x3(\v\x3\x3\x3"+
		"\x3\x3\x5\x3,\n\x3\x3\x3\x3\x3\x5\x3\x30\n\x3\x3\x4\x3\x4\x3\x4\x3\x4"+
		"\x3\x4\x3\x4\x3\x4\x3\x4\x3\x4\x5\x4;\n\x4\x3\x5\x3\x5\x3\x5\x3\x5\x3"+
		"\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x3\x6\x5\x6J\n\x6\x3\a\x3"+
		"\a\x3\a\a\aO\n\a\f\a\xE\aR\v\a\x3\b\x3\b\x3\b\x3\b\x3\t\x3\t\x3\t\x3\n"+
		"\x3\n\x3\n\x3\n\x3\v\x3\v\x3\v\x3\v\x3\f\x3\f\x3\f\x4&P\x2\x2\r\x2\x2"+
		"\x4\x2\x6\x2\b\x2\n\x2\f\x2\xE\x2\x10\x2\x12\x2\x14\x2\x16\x2\x2\x3\x4"+
		"\x2\t\t\x10\x10\x63\x2\x1C\x3\x2\x2\x2\x4\x1E\x3\x2\x2\x2\x6:\x3\x2\x2"+
		"\x2\b<\x3\x2\x2\x2\n@\x3\x2\x2\x2\fK\x3\x2\x2\x2\xES\x3\x2\x2\x2\x10W"+
		"\x3\x2\x2\x2\x12Z\x3\x2\x2\x2\x14^\x3\x2\x2\x2\x16\x62\x3\x2\x2\x2\x18"+
		"\x1D\x5\x4\x3\x2\x19\x1D\x5\b\x5\x2\x1A\x1D\x5\n\x6\x2\x1B\x1D\x5\f\a"+
		"\x2\x1C\x18\x3\x2\x2\x2\x1C\x19\x3\x2\x2\x2\x1C\x1A\x3\x2\x2\x2\x1C\x1B"+
		"\x3\x2\x2\x2\x1D\x3\x3\x2\x2\x2\x1E\x1F\x5\f\a\x2\x1F+\a\n\x2\x2 !\a\x3"+
		"\x2\x2!&\x5\x6\x4\x2\"#\a\x4\x2\x2#%\x5\x6\x4\x2$\"\x3\x2\x2\x2%(\x3\x2"+
		"\x2\x2&\'\x3\x2\x2\x2&$\x3\x2\x2\x2\')\x3\x2\x2\x2(&\x3\x2\x2\x2)*\a\x5"+
		"\x2\x2*,\x3\x2\x2\x2+ \x3\x2\x2\x2+,\x3\x2\x2\x2,/\x3\x2\x2\x2-.\a\x6"+
		"\x2\x2.\x30\x5\n\x6\x2/-\x3\x2\x2\x2/\x30\x3\x2\x2\x2\x30\x5\x3\x2\x2"+
		"\x2\x31\x32\a\x3\x2\x2\x32\x33\x5\x4\x3\x2\x33\x34\a\x5\x2\x2\x34;\x3"+
		"\x2\x2\x2\x35\x36\a\x3\x2\x2\x36\x37\x5\b\x5\x2\x37\x38\a\x5\x2\x2\x38"+
		";\x3\x2\x2\x2\x39;\x5\f\a\x2:\x31\x3\x2\x2\x2:\x35\x3\x2\x2\x2:\x39\x3"+
		"\x2\x2\x2;\a\x3\x2\x2\x2<=\x5\f\a\x2=>\a\x6\x2\x2>?\x5\n\x6\x2?\t\x3\x2"+
		"\x2\x2@\x41\x5\f\a\x2\x41\x42\a\x6\x2\x2\x42\x43\x5\xE\b\x2\x43\x44\a"+
		"\x6\x2\x2\x44\x45\x5\x10\t\x2\x45\x46\a\x6\x2\x2\x46I\x5\x12\n\x2GH\a"+
		"\x6\x2\x2HJ\x5\x14\v\x2IG\x3\x2\x2\x2IJ\x3\x2\x2\x2J\v\x3\x2\x2\x2KP\a"+
		"\x12\x2\x2LM\a\x13\x2\x2MO\a\x12\x2\x2NL\x3\x2\x2\x2OR\x3\x2\x2\x2PQ\x3"+
		"\x2\x2\x2PN\x3\x2\x2\x2Q\r\x3\x2\x2\x2RP\x3\x2\x2\x2ST\a\f\x2\x2TU\a\a"+
		"\x2\x2UV\a\v\x2\x2V\xF\x3\x2\x2\x2WX\a\r\x2\x2XY\a\b\x2\x2Y\x11\x3\x2"+
		"\x2\x2Z[\a\xE\x2\x2[\\\a\a\x2\x2\\]\x5\x16\f\x2]\x13\x3\x2\x2\x2^_\a\xF"+
		"\x2\x2_`\a\a\x2\x2`\x61\a\x11\x2\x2\x61\x15\x3\x2\x2\x2\x62\x63\t\x2\x2"+
		"\x2\x63\x17\x3\x2\x2\x2\t\x1C&+/:IP";
	public static readonly ATN _ATN =
		new ATNDeserializer().Deserialize(_serializedATN.ToCharArray());
}
} // namespace NoFuture.Antlr.Grammers
