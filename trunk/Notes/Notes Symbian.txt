Notes Symbian OS Developement

Developing Series 60 Applications: A Guide for Symbian OS C++ Developers
By: Leigh Edwards; Richard Barker
Publisher: Addison-Wesley Professional
Pub. Date: March 01, 2004
Print ISBN-10: 0-321-22722-0
Print ISBN-13: 978-0-321-22722-5
Pages in Print Edition: 800

Quick Recipes on Symbian OS: Mastering C++ Smartphone Development
By: Michael Aubert
Publisher: John Wiley & Sons
Pub. Date: August 25, 2008
Print ISBN: 978-0-470-99783-3
Web ISBN: 0-470997-83-4
Pages in Print Edition: 382

----
Getting Started
 - w/ Carbide.c++ GUI get a quick message box with 
iEikonEnv->AlertWin(_L("My Message!"));
----

----
Projectname.mmp
 - one for ea. Proj.
 - including one for ea. Ref'ed proj
bld.inf
 - single build file for entire solution
bldmake tool
 - builds a .bat file from bld.inf
 - 'abld.bat' is created
 - specific sdk 'make' files
----

----
Carbide.c++ Import Existing Projects
 - have the project unpacked and in the typical file structure
 - File > Import
 - select 'Symbian OS'/'Symbian OS Bld.inf file'
 - upon Next, browse to projects group/bld.inf file and select
 - follow wizard steps until complete...
----

----
Symbian Extensions
 - User Interface Resource file .rss
  - Resource Source Script
  - defines GUI L&F
 - Application Info. File .aif
  - needed for deployment
  - if missing, app gets defaults
 - Binary GUI Exe .app
 - Consule app .exe
 - Binary Resource .rsc
  - .rss compiled ver. 
 - compressed multibitmap .mbm
 - installation file .sis
 - app header .hrh
  - defines app specific constants
 - .rh file, resources used by the .rss
  - defined by SDKs
----

----
8 kb default stack size
 - override w/ EPOCSTACKSIZE 
 - place in .mmp file
1 MB heap size
 - override w/ EPOCHEAPSIZE
 - place in .mmp file
 - not enforced by emulater
Use of word 'model' for app engine
UI is divided into 
 - display of data
 - event handler
Deployed app path required as
 - <root>\system\apps\<appNm>\
 - 'not found' error
  - app UID is incorrect
 - deployment file is missing
Deployment files (Carbide.c++ GUI style)
 - CAknApplication (MyGUIApplication) 
  - not part of the MVC by needed by S60 to function
 - CAknDocument (MyGUIDocument)
  - this is the 'model'
  - saving data and reloading it is this classes job
 - CAknViewAppUi (MyGUIAppUi)
  - this is the 'controller'
  - this is where the event handlers are
 - CAknView (MyGUIFormView)
  - this is the container of the actual 'view'
  - is an aggregate part of the view
  - should be displaying whatever is in the 'model'
  - all the view is responsiable for actually displaying something
 - CAknForm (MyGUIForm)
  - this is the container for the other controls (ie textbox, combobox, etc)
  - is part of the 'view' of the S60 version of the MVC
  - is owned by the FormView 
----

----
Naming Conventions
 T class - has no heap alloc mem
  - contain all thier data internally
  - there are no pointers w/i the T-class types
  - there is no destructor
  - if its going to be bigger than 512K then make it a C-class
 S class - for sturctures
 C class - for heap alloc 
  - inherit from CBase 
  - need to be cleaned up
  - may own pointers
 R class - handle to OS Server resource
  - not inherited from base class
  - call to resource, 'Open', 'Connect'
  - must call a 'Close'
  - own some sort of resource handle
 M class - 'mixins', are interfaces
  - are purely abstract classes
  - all funtions have virtual modifer
 N is used for namspaces
 K is for constants
 E is for Enum members
 
 Static Classes
  - have not letter prefix
  - have only static methods
  - methods are called using scope operator '::'
  - eg. User, Mem, Math
 
 All instance var. Prefixed w/ 'i'
  - i for instance
 A parameters prefixed w/ 'a'
  - a for arguement
  
 GLDEF_C
  - an empty macro that is used to denote a global entry point
 LOCAL_C 
  - macro that just redefines as 'static' modifier
  - is used for classes
 LOCAL_D
  - macro that just redefines as 'static' modifier
  - is used for data  
----

----
Basic Types
 - are all Symbian specific 'T' classes
 - always use instead of std C++ type
 - are typedef'ed in e32def.h file of the SDK
 
 Tint - 32bits, signed int
 TUint - 32bits, unsigned int
 Tint64 - 64bits signed int
  - explict calls also to Tint8, 16 & 32
 TReal - double percision float
 - also have TReal32 & 64
 - TRealx is upto 92 bits
 TText - storage of Unicode Char
 TChar - store extnded Unicode char
 TBool - 32 bit boolean
 TAny - used as pointer to anything
---- 

----
In S60 - exceptions are runtime errs
 - caused by 'out-of-mem' for e.g.
Panics are caused by logic error
 - panics are from bad programming
 - they cannot be trapped
 - will cause running thread to terminate 
Constuctors should include (ELeave)
Obj* myobj = new (ELeave) Obj;
Functions that may 'Leave' end in L
Current function is a Leave type if
 - calls function w/ 'L'
 - calls a 'new (ELeave)'
----
 
---- 
Traps
 - special error handling
 //example
void DoMainL {
 //wrap function call in TRAPD,
 //or in TRAP
 TInt leaveCode;
 TRAP(leaveCode, LeaveMethodL());
 if(KErrNone == leaveCode)
  {
    //no error
  }
  else
  {
    //handle error
  }
 
Call 'User::Leave();' to 'throw' exit
 - User::LeaveIfError();
 - User::LeaveNoMemory;
 - User::LeaveIfNull;
Calling these pass back up to TRAP
 - Tint error is pass up as arguement
TRAPD versus TRAP 
 - in TRAPD the Tint parameter is not declared
  - it is defined for you
 - in TRAP the Tint parameter is must be declared
---- 

----
Local Variable Memory Management
 
CleanupStack::PushL(myLocalObj);
CleanupStack::Pop(myObj);
 - critical resource handles
 - in e32base.h header file
 - push local ref's to stack
 - pull them back off
 - free heap mem. if Leave happens
 - no 'finally' so use this...
 - this is exclusivly for local variables
  - instance data is reclaimed in the classes destructor
CleanupStack::Pop(Tint numOfItems, TAny* lastExpectedItem)
 - this can be used to pop off many local objects in one call
 - the Tint is the number of pointers being popped
 - the TAny* is the last item to be popped
CleanupStack::PopAndDestroy(Tint number, TAny* lastItem)
 - need to call delete still after popping a pointer off the stack
 - use this to accomplish it all in one call
----

----
CleanupStack GOTCHAS
 - cannot call CleanupStack unless current function is called from a TRAP
 - upon TRAP if the number of calls to CleanupStack is incorrect - get a Panic
 - CleanupStack::Pop() will panic if the CleanupStack is empty
 - CleanupStack::Pop() will panic if what is popped is whats at stack's top
---- 

----
Two Phase Construction
 - phase one is init only
 - phase two is allocation
 - mem. block init from phs 1 
  - may be cleaned up if phs 2 fail
 - phase one is C++ new operator
 - phase two is a function 
  - always called ConstructL
  - should be private or protected
 - use static factory function
  - always called 'NewL'
  - should always be static
  - construct phase 1 & 2 
  - return full alloc class
  - handles possiable fail 
static CMyObj NewL(TAny* constructorParam)
{
  //sets up mem. alloc. for CMyObj
  CMyObj* lcl = new (ELeave) CMyObj(constructorParam);
  //now that its on the CleanupStack an leave can occur 
  //without worry of the mem. alloc being lost
  CleanupStack::PushL(lcl);
  //here is the code that could cause the problems
  lcl->ConstructL()
  //if your here then no problems occured
  CleanupStack::Pop(self);
  //bye
  return self;
}
----

----
Descriptors 
 - think Strings
 - used to typically store string data
 - may store binary and serialized objects
 - use the standard <, >, == and != to compare text
  - compares the text as expected not binary rep thereof
 - for arguement passing use
  const TDesC& /*if you don't want the method to change it*/ 
  TDes& /*to allow method body to change it*/
 - the 'C' at the end means the length is constant
 - any descriptor type may have a specifier (eg TBuf8, TDes16)
  - the 8 means each 'cell' in the array is one byte
  - for 16 each cell is 2 bytes
 - use unspecified type for strings and specified type for binary data
 
TBufC<9>
 - this array is on the program's stack
 - the length is in pos.[0]
 - 9 is 'max length' cause its a 'C' descriptor type
  __ __ __ __ __ __ __ __ __ __
 |9 |M |y |  |S |t |r |i |n |g |
 |__|__|__|__|__|__|__|__|__|__|

TBuf<9>
 - this array is on the program's stack
 - current length is at pos. [0]
 - max length is at pos. [1]
  __ __ __ __ __ __ __ __ __ __ __ __
 |5 |10|B |r |i |g |e |  |  |  |  |  |
 |__|__|__|__|__|__|__|__|__|__|__|__|

TPtrC
 - a pointer is on the program's stack
 - on ptr pos. [0] is the length of descriptor on the heap
 - ptr pos. [1] is the pointer itself
 __ __      __ __ __ __ __ __ __ __ __ __
|10|* |--->|M |y |  |S |t |r |i |n |g |s |
|__|__|    |__|__|__|__|__|__|__|__|__|__|

TPtr
 - the pointer is on the program's stack
 - pos. [0] is current length
 - pos. [1] is the pointer itself
 - pos. [2] is the max length of the descriptor on the heap
 - initialize using () at end (TPtr myPtr();)
 __ __ __      __ __ __ __ __ __ __ __ __ __ __ __
|10|* |12|--->|M |y |  |S |t |r |i |n |g |s |  |  |
|__|__|__|    |__|__|__|__|__|__|__|__|__|__|__|__|

HBuf
 - just a straight pointer
 __      __ __ __ __ __ __ __ __ __ __ 
|* |--->|M |y |  |S |t |r |i |n |g |s |
|__|    |__|__|__|__|__|__|__|__|__|__|
 
                     ____________________________ 
                    |TDesC                       |
                    |____________________________|
                    |Alloc()      LocateReverse()|
                    |Compare()    Match()        |
                    |Find()       Mid()          |
                    |Left()       Ptr()          |
                    |Length()     Right()        |
                    |Locate()     Size()         |
                    |____________________________|
                          ^     ^          ^   
 _________________________|__   |          |   
|TDes                        |  |      ____|_____
|____________________________|  |     |TBufCBase |
|Append()     MaxSize()      |  |     |__________|<--| 
|Capitalize() Num()          |  |     |          |   | 
|Collate()    PtrZ()         |  |     |__________|   | 
|Copy()       Repeat()       |  |         ^          | 
|Delete()     Replace()      |  |         |          | 
|Fill()       SetLength()    |  |         |          | 
|Fold()       SetMax()       |  |         |          | 
|Format()     Swap()         |  |         |          | 
|Insert()     Trim()         |  |         |          | 
|Justify()    UpperCase()    |  |         |          | 
|LowerCase()  Zero()         |  |         |          | 
|MaxLength()  ZeroTerminate()|  |         |          | 
|____________________________|  |         |          | 
    ^         ^                 |         |          | 
 ___|____  ___|____          ___|____  ___|____  ____|____
|TBuf<n> ||TPtr    |        |TPtrC   ||TBufC<n>||HBufC    |
|________||________|        |________||________||_________|
|        ||Set()   |        |Set()   ||Des()   ||Des()    |
|        ||        |        |        ||        ||New()    |
|        ||        |        |        ||        ||NewMax() |
|        ||        |        |        ||        ||ReAlloc()|
|________||________|        |________||________||_________|
----

----
Descriptor Literals
 - typical way to make string literals 
 - unlike all other descriptors these end with the standard \0 (term. char)
 _L("sting literal on the fly!");
   //creates a TPtrC
 _LIT(MyString, "my String Value!"); //returns TLitC to use anywhere for TDesC&
   MyString() //this will cast it to a descriptor
 _LIT8(MyStrEight, "12345678"); //needed for those nasty ones w/ '8' at the end
----

----
Descriptor - Receipes
/*create TPtr from a literal*/
_LIT(KLiteral, "a literal");
TBufC<28> litTBuf(KLiteral);
TPtr litTPtr = litTBuf.Des();
//ConvertToUnicodeFromUtf8() 
 /*Concat two strings*/
 _LIT(KStringOne, "My First String");
 _LIT(KStringTwo, "My Second String");
 TBuf<128> myBuf1(KStringOne);
 TBuf<128> myBuf2(KStringTwo);
 //now call TBuf's += operator
 //this will blow a panic when the myBuf1 isn't large enough to hold the concat
 myBuf1 += myBuf2;
 //can also use 
 myBuf1.Append(myBuf2);
 
 /*Covert Num to String, and back*/
 TUint myInt = 99;
 TReal myReal = 33.3;
 TBuf<128> myBuf;
 //unsigned int into the descriptor
 myBuf.NumUC(myInt);
 //float into the descriptor
 TRealForm fmt(KDefaultRealWidth,2);
 buf.Num(myReal,fmt);
 //string to num
 _LIT(KmyNum,"88");
 TInt myOtherInt = 0;
 //Use TLex to make the unbox happen
 TLex lex(KmyNum);
 TInt err = lex.Val(myOtherInt);
 //Check for errors here...
 //myOtherInt should equal 88
 
 /*Parse out a string*/
 //create the string literal
 _LIT(KmySentence,"My Sentence has spaces.");
 //put it into a buffer
 RBuf aBuf;
 //placing into a buffer requires error checking
 if (aBuf.Create(KmySentence) != KErrNone) return;
 //put the buffer into a TLex
 TLex myLex(aBuf);
 //seperator is space character inheriently
 //these have to be pointer since they are *part* of a descriptor
 TPtrC myFirstWord = myLex.NextToken(); //My
 TPtrC mySecWord = myLex.NextToken(); //Sentence
 TPtrC myThirdWord = myLex.NextToken(); //has
 TPtrC myForthWord = myLex.NextToken(); //spaces.
 //think of TPtrC as a two-cell block 
 // - block one has the length
 // - block two has a pointer to the value
----

----
Descriptors as Method Arguments
//the 'const' on return type means the caller cannot change it upon return
//don't put 'const' on the arguement or you agree not to change it...
const TDes& CMyClass::AppendText(TDes& txt){
  //get the string literal to append 
  _LIT(KText, " Append");
  //the TDes::Append() requires the arguement be of the 'C' type
  TBufC<16> bufC(KText);
  //now append it to the TDes
  txt.Append(bufC);
  //give it back modified
  return txt;
}
----

----
Collection (Generics) Classes
 CArray
  - most flexable 
 RArray
  - most efficent
  - templated with R and T Types
  - need to be closed 
 RPointerArray
  - owns pointers to heap objects
 
 RArray<TInt> iMyRArray;
 RPointerArray<TInt> iMyPtrArray;
----

----
Symbian Active Objects 
 - Back To Basics
  - execution of a program is the runtime
  - this runtime is called a process
  - 'sequential processes' is having the CPU swapped from one to the next
  - the switching of processes is called Multiprogramming
  - Multitasking is having each process get some slice of CPU time
   - Multiprogramming, switch made when program has to wait for something
   - Multitasking, switch is made upon scheduling
  - Cooperative Multitasking
   - each process gives up its CPU time voluntarily
  - Preemptive Multitasking
   - use of interupts and hard timeslices of CPU
  - Multithreading was created because programs began running multiple processes
   - Throughput could be increased if multi-processes shared some memory space
   - multithreading is the implementation of that idea
   
 - Symbian OS has all programs running as Preemptive Multitasking
 - each program has one thread so its called Preemptive Multithreading
 - w/i each thread an Active Scheduler may be installed
  - active scheduler divides up its thread's CPU time among its Active Objects
 - multiple Active Objects may be contained in a single thread (aka process)
 - upon scheduler giving some CPU time to an Active Object
  - the active object may keep it all as long as it wants (Cooperative)
  - the active object has to surrender control back to the scheduler
 - .app (aka UI) already have a Active Scheduler installed
 - .exe (aka Console) need to have one installed by the programmer
 - this arch. is used to handle events in Symbian
 
 - Symbian event handling is a Client/Server Design Pattern
  - Asynchronous Client/Server Pattern (ACS)
   - the Client calls the server method by sending a message
   - the Client returns upon making the call, not upon completion of request
   - the Server processes the request 
   - the Server then notifies the Client of completion
 - Synchronous Client/Server Pattern (SCS)
  - is the exact same except the Client suspends until the Server is done
  
 - ACS requires the client to keep track of thier calls to the server
 - Symbian event handling is ACS 
 - call to server always contains a TRequestStatus arguement 
  - stores the completion code from the server
 - the Active Scheduler checks for changes in the status on waiting objects
 - upon finding a change it calls that Active Objects RunL() method
  - the RunL method is who handles the server's completion code
 - Active Objects inherit from CActive
  - the TRequestStatus is stored on CActive's iStatus instance variable
 
 - Order of Active Object Operation
  - Active Obj. is instantiated and added to the Active Scheduler
  - Active Obj. makes call to server, passing its iStatus as an arguement
  - the call to server sets iStatus to KRequestPending
  - Active Obj. calls its SetActive() method
   - this informs the scheduler that it must track this Active Object
  - the scheduler is in a loop checking iStatus on those who called SetActive()
  - server completes request, sets iStatus to a return code (KErrNone hopefully)
  - scheduler sees iStatus change and calls Active Objects RunL()
   - the RunL() may infact call the server again - rinse and repeat
   - upon Active Object's RunL() call, its got all the thread's CPU time!
   - RunL() is trapped, upon error scheduler calls RunError()
  - a RProcess owns RThread who owns CActiveScheduler who owns all CActive
  
  - CActiveScheduler::Install(); adds it to the thread
  - CActiveScheduler::Add(); adds the Active Objects to it
  - CActiveScheduler::Start(); starts the scheduler looking for events
   - once this is called it doesn't return until an event is processed
   - if SetActive() hasn't been call on an Active Obj. - endless loop...
   - also if all Active Obj's iStatus remain pending - endless loop... 
  - CActiveScheduler::Stop(); stops it 
   - only way to return from ::Start()!
   - will have to be called from an Active Object's RunL() method
----

----
Symbian OS Architecture
 - AppArc
  - short for Application Architecture
  - bottom, foundation classes
  - mostly abstract
 - CCoe
  - Control Enviornment
  - handling user input
  - creating user interfaces
  - also bottom, foundation classes
  - mostly abstract
 - Uikon
  - generic, concrete classes for UI library
  - specific to Symbian
 - Avkon 
  - UI specific to the Series 60
  - should be used instead of more generic Uikon
  - have CAkn prefix
----

----
S60 Event Handling
 - Commands
  - associated with softkeys 
  - since Options softkey is on the View - it is the view who receives the event
  - CAknView::HandleCommandL(TInt acommand){}
   - the 'acommand' is mapped to some constant in a .hrh file
   - if the view doesn't handle command - CAknViewAppUi::HandleCommandL gets it
 - Key Events
  - the event is passed as the TKeyEvent struc
  - all key events have a EEventKeyDown, EEventKey, EEventKeyUp
  - keyevents are handed down a stack of controls
   - the top of the stack is the most recently added control
   - to allow 'pass-through' control returns EKeyWasNotConsumed
  - controls are added to a stack calling AddToStackL 
  - key events are passed down this stack until a control 'consumes' the event
   - only top-level control should be added to the stack
   - controls w/i a control should not be added 
  - controls may be set as 'observer' to get notice of another controls events
   - the observer class implements an 'Observer' interface
   - single 'HandleEventL' needs to be implemented
----

----
Carbide.c++ UI Startup
 CAknApplication class
 - has the E32Main
  - calls EikStart::RunApplication
 - E32Main calls the generic NewApplication
  - returns your Application.cpp class
 - TUid returned by a call the generic AppDllUid
  - this matches whatever it is in the .mpp file
 - CreateDocumentL returns a pointer to the CAknDocument class
 
 CAknDocument class
 - CreateAppUiL is the static method that returns pointer to CAknViewAppUi
 - is owned by app
 
 CAknViewAppUi class
 - this is the class used to switch between forms
 - sits under the other controls and gets events/commands not handled above
 - is owned by Document
 
 CAknView class (1...*)
 - this is a container for the other controls 
 - softkey commands get handled here
 - is owned by AppUi
 - doesn't handle any key events, just softkey commands (unless you want it too)
 - has reference back to AppUi with 'AppUi()'
 - is added to Event stack by the AppUi, so it has an OfferKeyEventL
 
 CCoeControl, CAknForm 
 - control owned by the view
 - added to Event stack by view
 - those that are controls will implement Observer interface
  - setting its owned control (ie listbox) as what its observing
---- 

----
Symbian Console Basics (Hello World)

 /*HEADER FILE*/
 #ifndef EMPTYPROJECTAPPLICATION_H_
 #define EMPTYPROJECTAPPLICATION_H_

 #include <e32base.h>
 GLDEF_C TInt E32Main();
 #endif /* EMPTYPROJECTAPPLICATION_H_ */

 /*CPP FILE*/
 #include "EmptyProjectApplication.h" //of course
 #include <e32base.h> //these two are always here...
 #include <e32std.h>
 #include <e32cons.h> //needed for the console object

 //he is global
 // - is constructed inside a TRAPD
 // - is destructed before the return
 LOCAL_D CConsoleBase *console;

 LOCAL_C void MainL(){

 	console->Write(_L("Hello World!\n"));//all that for this!
 }

 LOCAL_C void DoStartL(){

	CActiveScheduler *sch = new (ELeave) CActiveScheduler;
	CleanupStack::PushL(sch);
	CActiveScheduler::Install(sch);
	
	MainL();
	
	CleanupStack::PopAndDestroy(sch);
 }
 //this is the main statement in Symbian
 GLDEF_C TInt E32Main(){ 
  //this is for debugging
  // - wrap all your code between this and the counterpart call __UNHEAP_MARKEND
  // - check that programmer cleaned up stack 
  // - will send a panic if you missed a something 
	__UHEAP_MARK;
  //not clear on this - appears its only needed for Console apps
	CTrapCleanup *cln = CTrapCleanup::New();
  //instantiate the Console object
  // - TSize is a arch. object
  // - KConsFullSize is an arch. constant
	TRAPD(cErr, console = Console::NewL(_L("MyConsole"), TSize(
			KConsFullScreen, KConsFullScreen)));
	if(cErr)
		return cErr;//pretty simple error checking, KErrorNone = 0 so this works
	TRAPD(mainErr,DoStartL());//here is where the action happens
	if(mainErr)
		console->Printf(_L("error  : %d\n"),mainErr);
	console->Printf(_L("press any key...\n"));
	console->Getch();//get the key-press from the console
	
	delete console;//clean up objects
	delete cln;
	__UHEAP_MARKEND;
	return KErrNone;
 }
----

----
IO - Basics
 - #include <f32file.h> in the header file
 - efsrv.lib included in the LIBRARY of the mmp file
 - similar to DOS/Windows
  - Drive letter followed by a colon
  - directory seperator char is \
  - extension seperated by dot
 - fully qualified names cannot exceed 256 characters
 - Symbian S60 c:\ is main drive
  - system files
  - user protected data
 - reference to the File System is R-Type
 - RFs for File Server
 - RFile for read/write to files
 
 Connect() is connection
 Close() is to close before object destruction
 MkDir() will make the dir assuming the rest of the path already exist
 MkDirAll() will make the entire path, including all parent dir's
 RmDir() removes the director and it must be empty
 SessionPath() get current working directory
 SetSessionPath() set the working directory somewhere else
----

----
IO - Search Directory

 CDir *myDir = NULL;//array of the files
 RFs *myRf = NULL; //the resource used to get to the file system
 If (myRf->Connect()) 
 {User::LeaveIfError(myRf->GetDir( //no L at the end....hmm..
                       _L("c:\myFolder"), //path
                       KEntryAttNormal, //specify file types
                       ESortByDate, //sort type
                       myDir); //directory object, comes back populated
                      )
 }
 myRf->Close();
 delete myDir;
----

----
IO - Read\Write File

/*==TEXT FILE==*/
 void CTextFileAppUi::ReadFromTextFileL(RFs& aFs, const TDesC& aFileName)
	{
	// Open the file for reading.
	RFile file;
	User::LeaveIfError(file.Open(aFs, aFileName, EFileRead | EFileStreamText));
	//will perform cleanup and the Close operation
	CleanupClosePushL(file);
	
	// Create a new instance of TFileText that point to file variable.
	//TFileText is for reading text from a file, one line at a time
	TFileText fileText;
	fileText.Set(file);
	
	// Create a buffer to read the text file.
	TBuf<KMaxBuffer> buffer;
	
	// Loop to read the buffer. It read the buffer until err is KErrEof,
	// which means it reached end of file.
	TInt err = KErrNone;
	while (err != KErrEof) //this is specific to TFileText only!
		{
		err = fileText.Read(buffer);
		
		// If the error code is other than KErrNone or KErrEof,
		// leave this function.
		if ((err != KErrNone) && (err != KErrEof))
			{
			User::Leave(err);
			}
		if (KErrNone == err)
			{
			// Do something with the buffer.
			// In this example, we append the buffer to an array.
			iBuffer.ReAllocL(iBuffer.Length() + buffer.Length() + 1);
			iBuffer.Append(buffer);
			iBuffer.Append(KDelimiter);
			}
		}
	CleanupStack::PopAndDestroy(&file);
	}
	
/*==READ FROM STREAM==*/	
void CFileStreamAppUi::WriteInt32ToStreamL(RFs& aFs,
		const TDesC& aFileName, TInt32 aValue)
	{
	// Open the file stream.
	RFileWriteStream writeStream;
	User::LeaveIfError(writeStream.Replace(aFs, aFileName, EFileWrite));
	CleanupClosePushL(writeStream); //may be written as writeStream.PushL();
	
	// Write a TInt32 to the stream.
	writeStream << aValue;//writeStream.WriteInt32L(aValue); as well
	                      // the << will not work for TInt
	
	// Commit the change and close the stream.
	writeStream.CommitL();
	CleanupStack::Pop(&writeStream);
	writeStream.Release();
	}
  
/*==WRITE TO STREAM==*/
TBuff CFileStreamAppUi::ReadInt32FromStreamL(RFs& aFs,
		const TDesC& aFileName)
	{
	// Open the file stream.
	RFileReadStream readStream;
	User::LeaveIfError(readStream.Open(aFs, aFileName, EFileRead));
	CleanupClosePushL(readStream);

	// Read a TBuff from the stream.
  TBuf<KMaxBuffer> buffer;
  readStream >> buffer;
	
	// Close the stream and return the read TBuff.
	CleanupStack::PopAndDestroy(&readStream);
	return value;
	} 

/*==APPEND TO FILE WITH STREAM==*/
void CFileStreamAppUi::AppendInt32ToStreamL(RFs& aFs,
              const TDesC& aFileName, TInt32 aValue)
  {
  // Open the file stream.
  RFileWriteStream writeStream;
  TInt err = KErrNone;
  //BaflUtils is for one-off file create, deletes and exists
  if (BaflUtils::FileExists(iCoeEnv->FsSession(), aFileName))
    {
    err = writeStream.Open(aFs, aFileName, EFileWrite);
    }
  else
    {
    err = writeStream.Create(aFs, aFileName, EFileWrite);
    }
  User::LeaveIfError(err);
  writeStream.PushL();

  // Move the file pointer to the end of file.
  //.Sink() gets at ref to the underlying stream - on this SeekL is called
  //MStreamBuf::EWrite is present since the stream has write and read pointers
  writeStream.Sink()->SeekL(MStreamBuf::EWrite, EStreamEnd, 0);
  //use RFileReadStream::Source() to get the MStreamBuf on a read-stream

  // Write a TInt32 at the end of file.
  writeStream.WriteInt32L(aValue);

  // Commit the change and close the file.
  writeStream.CommitL();
  CleanupStack::Pop(&writeStream);
  writeStream.Release();
  }
----

----
Carbide.C++ Event Handling Structure
 - UI designer allows for VBesque event handling 
 - from 'Outline' view > select the control
 - within the 'Events' view > a list of possiable events is shown
 - double-click the preferred event and the IDE moves focus to code handler
  - depending on what control is select determines where handler is located
  - key events end up on the CCoeControl w/i the view (eg form, listbox, etc)
  - command events end up on the CAknView object
 - to pass a key event back to CAknViewAppUi simply return EKeyWasNotConsumed
 - to pass a command back to CAknViewAppUi call AppUi()->HandleCommandL(...)
 - command enum values are mapped by IDE to fileName.hrh
 - the IDE generates alot of helper methods to do the work - use them
 - IDE generates the following upon selection of an event in the UI Editor
 
 //a type is defined in the header file
 //is simply a rename for a function pointer 
 typedef void (*MyEventHandler)(CCoeControl *myCtrl, TEvent myEvent);
  
 //a struc is defined in the header file as well
 //simply bundles a f(x) pointer with the needed argurements
 struct TMyEventDispatch{
    CCoeControl* src;
    TEvent evt;
    MyEventHandler handler;
 }
 // init the handlers and add them to a collection RArray<MyEventDispatch> icol;
 // the handler collection is an instance variable
 icol.Append(entry/*is of TMyEventDispatch type*/);
  
 //depending on implementation - 
 void HandleEvent(CCoeControl ctrl, TEvent evt){
	for (int i = 0; i < icol.Count(); i++)
		{
		const TMyEventDispatch& currEntry = icol[i];
		if ( currEntry.src == ctrl && currEntry.event == evt )
			{
			//clever implementation - using a loop instead of a switch...
			//this is where the IDE generated handler gets called
			( this->*currEntry.handler )( ctrl, evt );
			break;
			}
		}
 }
----

----
Carbide.c++ - ListBox Dynamic Item 
 - setup the project in Carbide
 - given component to handle event in UI editor

/* 
  - select componet in 'Outline'
  - right-click > Show Events View
  - given event, double-click
  - now in body of event-handler 
*/
void CMyProjectListBox::HandleListBoxEnterKeyPressedL( 
		CEikListBox* aListBox,
		TListBoxEvent anEventType )
	{
	//this list box is CAknSingleGraphicHeadingStyleListBox...
	//TBuf is what a list item actually is...
	TBuf<512> listString; 
	//use the IDE generated method to populate & format the TBuf
	CreateListBoxItemL( listString, 0/*icon index - 0 for default*/, 
                     _L("h")/*header text*/, 
                     _L("i")/*item text*/);
  //IDE gen'ed add function - just use this                     
	AddListBoxItemL( iListBox, listString );
	//AddListBoxItemL( iListBox, _L("0\th\ti") ); is a literal version
	}
----

----
Carbide.c++ Change View
 - add a menu item that is intended to change a view
 - handle the event 
 
 TBool CMyView::HandleIntendedViewChange(TInt aCommand)
  {
    const TUid indx = {EMyOtherViewId};//this is mapped in Project.hrh file
    AppUi()->ActivateLocalView(indx);
    
    return ETrue;
  }
----

----
Carbide.c++ SymbianOSUnit
 - place SymbianOSUnit folder into the workspace
 - copy both of the folders found in 'CopyToYourProject'
  - when asked if you want to add the new souce files to whatever - say no...
 - copy #include "./s60_3rd/bld.inf" into the original bld.inf file
 - go to the symbianosunit.mmp editor
  - in the 'Sources' tab > add your file which will be tested
  - in the 'Options' tab > add the path to your project's 'inc' folder
 - go into the TestHeader.h > add a #include "YourFileToTest.h"
 - go to > Project > Properties > Carbide.c++ > Project Settings
 - select Radio btn for "Selected Components" > place check next to everything
 - ensure that it builds
 - if any other project was being tested 
  - open that project
  - clean that project
 - run the debug to get a debug config setup
 - go to Run > Debug Configurations
 - select your debug config > right-click > Duplicate
 - rename it as needed
 - change 'Process to launch' to point to ...\SymbianOSUnit.exe instead
----
