----
Notes dotnet core
----

----
https://docs.microsoft.com/en-us/dotnet/core/
https://docs.microsoft.com/en-us/aspnet/core/client-side/spa/angular?view=aspnetcore-6.0&tabs=netcore-cli
----

----
.NET Core in Action
By: Dustin Metzgar
Publisher: Manning Publications
Pub. Date: July 20, 2018
Print ISBN-10: 1-61729-427-6
Print ISBN-13: 978-1-61729-427-3
Pages in Print Edition: 288
----

----
Overview
 - .NET Framework is the original, Windows-only framework
 - dotnet core is the rewrite machine-independent 
  - many dotnet SDK's may be installed on a single machine
 - .NET Standard allows for references to both dotnet and .NET Framework
 - after version dotnet 5.0, MS began just calling it .NET
PS C:\> dotnet --info

  - Windows-only stuff is not supported
   - registry
   - WIN32/COM interop
   - GAC
   - Special folders
  - AppDomain is out 
   - there is stuff in System.Runtime.Loader and
     Microsoft.Extensions.DependencyModel packages
  - XAML is out
  - distributed transactions are out
  - Remoting is out 
  - .asmx are not supported
  - LINQ to SQL is replaced with Entity Framework
  - WCF Services (as a host) are out 
   - there is some stuff for client's
  - Workflow Foundation, this depends on the other 
    stuff already rem'ed (WCF, XAML, etc.)
  - type reflection has changed
   - uses new class named TypeInfo 
 - ver. 1.0 used 'project.json', ver. 2.0 switched
   back to MSBuild .(vb|cs|fs)proj XML
 - idea of web.config\app.config is out 
  - many "forms" of configuration where those
    based on a file is but one of many
   - for file-based, use of file named "appsettings.json" 
     and "appsettings.{Environment}.json" 
   - use of containers means each is an autonomous 
     environment so the machine's environment var's
     are used for what was, prev., defined in web.config
 - idea of build's targeting an environment is out
  - instead the same build is used for all
  - the host defines its environment using environment varibles
   - for ASP.NET Core the variable is "ASPNETCORE_ENVIRONMENT"
----

----
Terminalogy (mostly NuGet in origin)
 - Moniker: the keyword name used to specify 
    a framework, runtime or platform (e.g. net471)
 - Target Framework: flavor of .NET 
  - e.g. net471, netcoreapp1.0
 - .NET Standard: another kind of target framework
    which works for all
  - a kind of, "I don't need to specify the 
    target framework because it works on all of them..."
 - Runtime: a couple, operating system and CPU arch
  - e.g osx.10.11-x64, linuxmint.17.1.x86
 - Platform: used without any sense to 
    mean runtime, framework, both or all
----

----
.(cs|vb|fs)proj Files Differences
 - there is no XML namespace 
 - expected that dev's will directly modify the (cs|vb|fs)proj file 
  - adding EmbeddedResource would need the dev to open it and add
    the node 
  - dev can use the MSBuild Conditionals 

 <PropertyGroup Condition="'$(MyParam)' == 'true'" />
 <PropertyGroup Condition="'$(OtherParam)' == 'false'" />
  - involves variable nesting (e.g. single quotes inside double-quotes)
  - can then be assigned another value at the dotnet CLI
PS C:\> dotnet build -p:MyParam=false,OtherParam=true
  
 - build output paths are not defined within proj file
  - instead are specified in the invocation of "dotnet build"
 - each src-code file does not get added as a "Compile" node
  - the src-code files to include in compilation is assumed 
    from current working dir.
 - references are of the two typical forms, binary or source-code
  - appears only binary form is as NuGet packages 
 - projects do not include an independent "packages.config" 
   since those are specified in the .(cs|vb|fs)proj file itself
 
PS C:\> dotnet add package Newtonsoft.Json
 - add a nuget (binary) package reference
 
PS C:\> dotnet add reference "C:\Projects\MyOtherProj\MyOtherProj.csproj"
 - add a source-code (project) reference
 
 - the new "PackageReference" node is a NuGet binary reference
  - the "Include" attribute is the NuGet package id
  - the "Version" attribute is the NuGet package version
 
 - the old "Reference" was a ref to a .dll 
  - the "Include" attribute was the assembly name 
   - for NuGet packages it was the full-qual. assembly name
   - for GAC references it was simple assembly name 
  - the "HintPath" child-node was only present on NuGet package ref's
 
 - new "ProjectReference" is mostly the same
  - the "Project" child-node is not added from dotnet CLI
   - probably still present when added from Visual Studio (.sln files)
  - the "Name" child-node is not added from dotnet CLI
----

----
Creating an Angular SPA with ASP.NET MVC backend

PS> dotnet new angular -o my-new-app
 - to create a new Angular and ASP.NET MVC app

PS> code .\my-new-app\
 - open in the VS Code IDE
 
PS> dotnet build
 - this will add the node_modules folder to the Angular project
 
PS> dotnet run
 - this will launch the ASP.NET MVC host _and_ a host to serve the
    Angular app
 - NOTE: when you add new controllers to the ASP.NET MVC proj, you
    need to add them likewise into the .\ClientApp\proxy.conf.js file

PS> cd ClientApp
    npm start
 - to launch an independent Angular host 
 - subsequent calls to 'dotnet run' will _not_ open the Angular app host
----

----
Adding a Unit Test Project
 - ref: https://docs.microsoft.com/en-us/dotnet/core/testing/unit-testing-with-dotnet-test
 - you can _not_ nest a unit test project in its test-target's project folder
 
 - add the unit test project
PS> dotnet new xunit -o MyProj.Tests

 - add a reference to the unit test proj of what is being tested
PS> dotnet add ./MyProj.Tests.csproj reference ./MyProj.csproj
----

----
Creating a Solution
 - the command will create a folder of the same name to house the .sln file
 - will allow for 'dotnet build' to build all projects on the solution
 
PS> dotnet new sln MySolution

 - add projects to the solution 

PS> dotnet sln add .\MyFirstProject\MyFirstProject.csproj

 - delete any PLATFORM environment variables 
PS> [System.Environment]::SetEnvironmentVariable("PLATFORM", $null, "User")
PS> [System.Environment]::SetEnvironmentVariable("PLATFORM", $null, "Machine")
----

----
Using CLI for DI types
 - there is a lot of hand-waving regarding DI in dotnet
 - typical DI types are configurations and logging
 ls .\MyProject.Cli\bin\Debug\net6.0\ -Filter *.dll `
  | foreach {[System.Reflection.Assembly]::Load([System.IO.File]::ReadAllBytes($_.FullName))}
 - the required packages 
 
PS> dotnet add package Microsoft.Extensions.Logging.Console
PS> dotnet add package Microsoft.Extensions.Configuration
PS> dotnet add package Microsoft.Extensions.Configuration.Json

 - will need to include the appsettings.json file to be copied to the 
   output directory by modifying the .csproj and adding
   
  <ItemGroup>
    <Content Include="appsettings.json">
      <CopyToOutputDirectory>Always</CopyToOutputDirectory>
    </Content>
  </ItemGroup>
 
 - example static methods to get DI types
using System;
using System.IO;
using Microsoft.Extensions.Options;
using Microsoft.Extensions.Logging;
using Microsoft.Extensions.Logging.Console;
using Microsoft.Extensions.Configuration;

namespace MyProject.Cli;

public class Etc
{
    private static ILoggerFactory _loggerFactory;
    public static IConfiguration GetCfgFromFile(string cfgFile)
    {
        if(string.IsNullOrWhiteSpace(cfgFile))
            throw new ArgumentNullException(nameof(cfgFile));
        
        if(!Path.IsPathRooted(cfgFile))
            cfgFile = Path.GetFullPath(cfgFile);
        
        if(!File.Exists(cfgFile))
            throw new FileNotFoundException("File missing or not found", cfgFile);

        var builder = new ConfigurationBuilder().AddJsonFile(cfgFile);
        var cfg = builder.Build();

        return cfg;
    }

    public static ILoggerFactory LoggerFactory 
    {
        get
        {
            if(_loggerFactory == null)
                _loggerFactory = new LoggerFactory();
            return _loggerFactory;
        }
    }

    public static ILogger<T> GetLogger<T>()
    {
        var logger = new Logger<T>(LoggerFactory);
        return logger;
    }
}
----

----
Using Custom Types for appsettings.json
 - custom types will be automatically deserialized 

 - requires an additional package
PS> dotnet add package Microsoft.Extensions.Configuration.Binder

 - example "appsettings.json"
{
    "Settings": {
        "Parent": {
            "FavoriteNumber": 7,
            "Child" :{
                "Name": "Example",
                "Grandchild": {
                    "Age": 3
                }
            }
        }
    }
}

 - followed by the actual types themselves
public sealed class Settings {
    public Parent Parent {get; set;}
}

public class Parent {
    public int FavoriteNumber {get; set;}
    public Child Child {get; set;}
}
public class Child {
    public string Name {get; set;}
    public Grandchild Grandchild {get; set;}
}

public class Grandchild {
    public int Age {get; set;}
} 
 
 - two different ways of getting the values out of the 
   appsettings.json
   
public class Program {
    public static void Main(string[] args ){
        try{
            var cfg = Etc.GetCfgFromFile("appsettings.json");

            Console.WriteLine($"Example 1 appsettings.json value {cfg["Settings:Parent:Child:Name"]}");

            var settings = cfg.GetRequiredSection("Settings").Get<Settings>();

            Console.WriteLine($"Example 2 appsettings.json value {settings.Parent.Child.Name}");

            var k = Console.ReadKey();
        }
        catch(Exception ex){
            Console.WriteLine(ex.Message);
        }
    }
}
----
  