----
Notes Go
Learning Go
First Edition And Idiomatic Approach to Real-World Go Programming
by Jon Bodner
O'Reilly Media 
978-1-492-07721-3
----

----
Kat Zien GopherCon 2018
https://youtu.be/oL6JBUk6tj0
----

----
Concurrency in Golang: A Simple, Practical Example
Rohit Awate
https://www.youtube.com/watch?v=3atNYmqXyV4
----

----
Overview
 - Go does not have:
  - inheritance
  - generics
  - function overloading
  - operator overloading
  - pattern matching
  - named parameters
  - exceptions


 - Go does have Pointers
 - Go will compile its own runtime into 
   every executable
  - dotnet v 5.0.403 "Hello World" is 123KB
  - go v 1.17.3 "Hello World" is 1881KB
  
 - only has 25 keywords
----

----
Basics
 - download the installer from 
  https://go.dev/dl/
  
 - the installer adds the necessary environment variables
  
 - to explicitly set the GOPATH environment variable
 [System.Environment]::SetEnvironmentVariable("GOPATH",(Join-Path $env:USERPROFILE "go") ,"Machine")

 - get installed version
 go version

 - get go environment settings
 go env
 
 - to run a go file like a script
 go run myGoFile.go
 
 - to build a go .exe
 go build myGoFile.go

 - get third party components
  - this will install a .exe in \bin folder of you GOPATH
  - Go seems to have no problems with corporate firewalls (?)
 go install github.com/rakyll/hey@latest
 
 - in Go the formatting is explicit 
  - best-practices at https://go.dev/doc/effective_go
 - the Go compiler will add semi-colons to all statements
 - the dev has to explicitly call a formatting command prior to compiling
 go fmt
 
 - another code scanning command used to find things like
  - wrong number of parameters
  - unused variables with assignment
  - run the vetting tool across your entire project 
 go vet ./...
 
 - third party linting tool 
  - one-time install command
 go install golang.org/x/lint/golint@latest
 
  - run the linter across your entire project
 golint ./...
 
 - to create a module in the working directory
 go mod init github.com/nofuture
----

----
Go Primitives
 - integer
  - has the common 8 types (4 signed, 4 unsigned)
  - can be written in decimal, binary, octal or hex
  - binary is prefixed with 0b
  - octal is prefixed with 0o
  - hex is prefixed with 0x
  - go allows for underscore to be present 
    in integer literal for readability
   - for example, speed of light m/s
  299_792_458

 - floats
  - can be written in decimal or hex
  - actual types are float32 and float64
  - scientific notation is allowed
   - for example Avogadoros Number
  6.022e23
  
 - chars
  - these are called 'runes' in Go
  - uses single quotes like C#
  - are Unicode 
   - literals can be 8, 16 or 32 bit
  '\x61' '\u0061' '\U00000061'
  
 - strings
  - literals are enclosed in double quotes
  - verbatim strings are enclosed in back-tick (0x61)
  `here is my 
  Here-String in go`
  
 - booleans
  - same as elsewhere
  - literal values are keywords 'true' and 'false'
  - default value is false
----

----
Go Operators

 - logical
 && || !

 - arithmetic 
  + - * / %
  
 - compound assignment ops
 += -= *= /= %=

 - comparison ops
 == != > >= < <=

 - bitwise ops
 << >> & | ^ &^ (logical AND NOT)
 
 - empty and nothing
  - Go has 'nil' and 'null'
  - nil is an identifier that lacks a 
    value for some known type

 - global builtin functions
  - len, various uses for getting a "length"
  - append, used to extend a slice
  - etc.
  
 - variadic parameters 
  - uses the three-dot convention '...'
----

----
Access Modifiers
 - are based on naming convention
  - camelCase identifiers are package-level scoped
  - PascalCase identifiers are exported and can be 
    imported by other modules
  - naming a package "internal" will make it only 
    accessible to the parent package
----

----
Variable Decl and Assignment
 - most explicit declaration and assignment
 var x int = 10
 
 - implicit type 
 var x = 10
 
 - declaration without assignment
 var int x
 
 - decomp decl and assignment
 var x, y int = 10, 20
 
 - implicit decomp decl and assignment
 var x, y = 10, "foo"
 
 - unique concept called declaration list
 var (
     x    int
     y        = 20
     z    int = 30
     d, e     = 40, "bar"
     f, g string
 )
 
 - within the body of a function a 
   syntax short-hand is ":="
 x := 10
 
 - constants are the same as in C#
  - if the constant is being used mathematically
    it should be declared implicitly so to avoid 
    casting
 const magicNumber = 42;
 
 - arrays
  - Go considers the length of an array as part of 
    its type
   - arrays of different lengths cannot be converted
 var x = [3]int
 var y = [3]int{2, 4, 6}
 
 - slices
  - Go has this idea as what most langs call an array
 var z = []int{10, 20, 30}
 
  - can specify indices in a slice-literal
 var m = []int{1, 5: 4, 6, 10: 100, 15}
   - the following would make the array
     [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]
     
  - to expand an array the global 'append' 
    function is used  
 var c = []int
 c = append(c, 10) 
 d = []int{88, 89, 90}
 c = append(c, d...)
   - this will append all of d to the tail of c
   
  - use the global 'cap' function to get 
    a slice's total capacity
  fmt.Println(cap(c))
  
  - use global 'make' function to init 
    a slice with an explicit size
  f := make([]int, 5)
   - makes a new slice with 'cap' of 5
 
  - a zero-length slice is not nil
 v := []int{}
----

----
Array Slices
 - a slice will be another variable to some
   part of an existing array
 - the memory is the same only the ref changes
 - on-the-stack a slice is a three-property struct 
   having a pointer to some array, a current-length and
   a capacity
  - when passed to a func changes: 
   - within the array _will_ be reflected 
   - to the current-length and capacity _will not_ be reflected
    
 
 var x = []int{1, 2, 3, 4}
 y := x[1:3]
 z := x[:] //another ref to the same 
 
 - to terminate the shared memory of a 
   slice-of-a-slice, use this three-part 
   slice expression
  - the final param terminates where the 
    shared part by index
 m := x[2:4:2] 
 
 - the builtin 'copy' will make an
   independent copy
  - the different lengths does not matter
 x := []int{1, 2, 3, 4}
 y := make([]int, 2)
 //first param is dest, second is source
 // 'n' is the number of elements copied
 n := copy(y, x)
----

----
Maps (a.k.a. Dictionary, Hashtable, Assoc. Array)
 - typical key-value pair
 - decl key-word 'map' with the key's type in sqr-braces
   followed by the value's type
 - will grow automatically
 
 myMap := map[string]int{}
 myMap["first-key"] = 12
 myMap["second-key"] = 42
 
 - map declaration with init
 var myTable = map[string][]string {
    "A-Team": []string{"BA", "Hannibal", "Mad Murdock", "Face"},
    "B-Team": []string{"Foo", "Bar"}
 }
 
 - key-value decomp has second decl as a bool 
   for testing if the key was present
  - 'v' would be the value of the pair if 
     the key is present
  - 'ok' is a bool which verifies that the key 
     was found
 v, ok := myMap["third-key"]
 
 - to remove an item from a map
  - returns 'nil' if key was not present
 delete(myMap, "first-key")
----

----
Structs
 - same as in other C-style langs
 - Go has no classes
 - structs are used to declare custom
   data-types
 
 - struct type-def
  - no commas in the the type-def
 type person struct {
    name string
    age int
    pet string
 }
 
 - declaration and init of a struct
  - commas are present in init
 myPerson := person{
    "Fred",
    28,
    "cat",
 }
 
 - declaration of an anon struct is 
   allowed
 var myCustomStruct struct {
    prop00 string
    prop01 bool
    prop02 int
 }
 
 myCustomStruct.prop00 = "some string"
 myCustomStruct.prop01 = true
 myCustomStruct.prop02 = 37
 
 - a declaration and init of an anon struct
 pet := struct {
    name string
    kind string
 }{
    name: "Princess",
    kind: "cat",
 }
 
 - struct conversion is very limited
  - the declaration order, name and type
    _MUST_ match exactly 
 type firstPersonType struct {
    name string
    age int
 }
 
 type secondPersonType struct {
    name string
    age int
 }
 
 - to alias a type to another name
  - alias will allow for different type assignment
 type Foo = Bar
----

----
Type Checking\Casting
 - is limited and used sparingly
 - the type being tested is after the variable 
   with a dot and in parenthesis  
   
 //testing if "i" is an "int"
 // "ok" will be true if it is and "myInt" will 
 //  be "cast" as an int
 if myInt, ok := i.(int)
----

----
Conventions
 - 'block' is considered any enclosure where
   a variable can be declared
  - every occurrence of a curly brace opens
    a new block
   - a switch statement's 'case' block is also a 
     true block but has no curly-braces enclosing it
  - the top-level block is called 'universe block'
  - the universe block contains many 
    "predeclared identifiers" 
   - 'int', 'string', 'true', 'nil', etc are 
     all predeclared identifiers 
    - as such, its possible to shadow these 
 - shadowed variables are when a variable 
   of the same name is declared within an
   inner-block.  
  - operates as expected, outer variable is 
    not accessible until inner variable goes
    out of scope
----

----
Branching
 - classic if statement is as expected
  - actual condition is not enclosed in parenthes 
  - a variable can be declared within an if statement
  
  if n := rand.Intn(10); n == 0 {
    fmt.Println("Too Low")
  } else if n > 5 {{
    fmt.Println("Too high")
  } else {
    fmt.Println("Too slow")
  }
  
 -likewise, multiple variable may be declared with the conditional
 if myInt, ok = i.(int); ok {
    //here is code that will run if the "cast" worked
 }
  
 - an enhanced switch statement
  - variables may be declared within a case's 
    block and is only scoped to it
  - Go's switch statements do _not_ have classic
    fall-through behavior
  - switch will work with anything comparable
    with the '==' op  
  var myWord = "something like this"
  switch size := len(myWord); size {
  case 1, 2, 3, 4:
  	fmt.Println(size, "whatnot")
  case 5:
  	var newVariable = 87
  	fmt.Println(size, newVariable)
  default:
    //newVariable will cause an error if used here
  	fmt.Println(size, "too big")
  }
----

----
Looping
 - Go does not have either 'while' nor 'do-while' loops
 - Go has the classic break and continue
  - the classic
 for i := 0; i < 10; i++ {
 
 }
  - the infinite 
 for { //ever
    fmt.Println("Hello")
 }
 
 - the 'do-while' replacement
 for {
    if someCondition == false {
        break
    }
 }
 
 - the for-each
  - uses a esoteric variable decomp decl
  - 'i' is the counter (a.k.a. index)
  - 'v' is the variable of iteration
 var myVals = []int{2, 4, 6, 8, 10, 12}
 for i, v := range myVals {
    fmt.Println(i, v)
 } 

 - when you don't care about the counter
 for _, v := range myVals {
    fmt.Println(v)
 }
 
 - when using a map, the variable decomp decl 
   is the key-value
 var myMap = map[string]bool{"Foo": false, "Bar": true, "Shoo": false}
 for k, v := range myMap {
    fmt.Println(k, v)
 }
 
 - go supports labels to specify the break and continues
 outer:
    for i, v := range myVals {
        if i = 3 {
            continue outer
        }
    }
----

----
Functions
 - parameter types and return types need to be specified
 - a void return-type does not have to be declared as such
 - a return statement is required if the function has a return type
 - Go does _not_ have optional parameters
 - Go's func parameters are _not_ named
 - Go _does_ have variadic parameters which are a three-dot followed 
   by the type
 - anon functions are allowed within the body of another named function
 
 func myDiv(numerator int, denominator int) int {
    if denominator == 0 {
        return 0;
    }
    return numerator / denominator
 }
 
 - a void return type with no parameters
 func myFunc() {
   //do nothing is fine (?)
 }
 
 - a variadic example
  - the variadic param is a 'slice' type
 func myVariadicExample(vals ...int) []int {
    return vals
 }
 
 - Go can return tuples
  - Go doesn't call them tuples, rather multiple return values
  - the decl of the return type is in parenthesis  
  - the return statement is _not_ in parenthesis
  - assignment of return types uses tuple-decomp
 func divAndRemainder(numerator int, denominator int) (int, int, error) {
    if denominator == 0 {
        return 0, 0, errors.New("cannot divide by zero")
    }
    return numerator / denominator, numerator % denominator, nil
 }
 
 - the multiple return values may be given names
  - this creates local variables within the body of the function
 func myOtherFunc(numerator int, denominator int) (result int, remainder int, err error) {
    if denominator == 0 {
        err = errors.New("cannot divide by zero")
        return result, remainder, err
    }
    result, remainder = numerator/denominator, numerator%denominator
    return result, remainder, err 
 }
 
 - higher order functions use the same 'func' keyword 
  - can be passed as parameters or returned 
 func myHigherOrder(something int, myFunc func(int, int) int) int {
    return myFunc(something, something)
 }
 
 - a function may be implemented in-line as a parameter
 sort.Slice(mySlice, func(i int, j int) bool {
    return mySlice[i] < mySlice[j]
 })
 
 - a function can be a type itself (like a delegate in .NET)
  - therefore a method can be added to it just like any other type
 type HandlerFunc func(string)
 
 func (f HandlerFunc) GetFunc(s string) {
    f(s)
 }
----

----
Methods 
 - methods may be defined for a type using a 
   special kind of function declaration
  - methods are different in-that they have 
    another part named "receiver" specification
  - the receiver appears after the 'func' and 
    before the method's name
  - when a method modifies its type its a pointer-receiver
  - when a method is read-only of its type its a value-receiver
 - declaration of methods must happen within the 
   same package 
    
 type Person struct {
    name string
    age int
    pet string
 }

 //a value-receiver with as string return-type
 func (p Person) ToString() string {
    return fmt.Sprintf("%s, age %d, pet %s", p.name, p.age, p.pet)
 }
 
 type MyCounter struct {
    total int
    lastUpdated time.Time
 }
 
 //a pointer-receiver with void return-type
 func (c *MyCounter) IncrementMe() {
    c.total += 1
    c.lastUpdated = time.Now()
 }
 
 - a method can be treated as a function pointer with ease
 c := MyCounter{
 	total:       0,
 	lastUpdated: time.Now(),
 }
 
 func (c MyCounter) ToString() string {
	return fmt.Sprintf("total: %d, last updated: %v", c.total, c.lastUpdated)
 }
 
 myFx := c.ToString
 fmt.Println(myFx())
 
----

----
Function body cleanup
 - uses the keyword 'defer'
 - is automatic to execute upon exiting the function
 - the run in order of last-in-first-out (bottom-to-top)
 
 f, err := os.Open("C:\Somefile\afile.txt")
 defer f.Close()
 //more code here to read contents
 
 - defer can be used on an anon closure
 - whatever is in-scope within the function's body may be
   in-scope within the defer 

 func myExample() {
    //inside a function here
    defer func() {
        if err != nil {
            myDb.Rollback()
        }
    }()
    //do more things here
 }
----

----
Go Pointers
 - basically the same as most managed langs pass-by-value semantics
  - only now allowed to de-ref a pointer
 - in a function\method signature having a pointer indicates 
   that the parameter _may_ be modified
 - the zero pointer is 'nil'
  - the same as with slices, maps and functions
 var mySlice = []int{1, 2, 3, 4}
 
 //declare a pointer using 'address-of' op '&'
 var myPointer = &mySlice
 
 //de-reference the pointer using 'indirection' op '*'
 fmt.Println(*myPointer)
 
 
 func failedUpdate(px *int) {
 
    //x, px and x2 all exist on the stack here
 	var x2 = 20
    //updating px to point somewhere else
 	px = &x2
    //stack unwinds and only x is left
 }
 
 func successUpdate(px *int){
 
    //px and x exists on the stack here
    //updating the value-of what px is pointing-to
 	*px = 20
    //stack unwinds and only x is left
 }
 
 func main() {
 	var x = 10
    //here only the value of the parameter is changed
 	failedUpdate(&x) //10
 	fmt.Println(x)
    //here the value of what the parameter is pointing-to changed
 	successUpdate(&x) //20
 	fmt.Println(x)
 }
----

----
Enums
 - is a two step declaration (typically)
 - is best practice to only use enums on internal code
 - like enums, will begin numbering at zero
 
 - first step is declare a type "based on" int
 - then declare a const and use some esoteric keywords (e.g. "iota")
 
 type MyRubric int
 
 const (
    DistantPast MyRubric = iota
    Past
    NearPast
    Present
    NearFuture
    Future
    DistantFuture
 )
----

----
Embedding Structs
 - a counterpart to the common idea of inheritance
 - is object composition, not object inheritance
 - does not allow for polymorphic arg passing
 - does not override embedded type's method\props 
 
 type Employee struct {
 	Name string
 	ID   string
 }
 
 func (e Employee) Description() string {
 	return fmt.Sprintf("%s (%s)", e.Name, e.ID)
 }
 
 type Hourly struct {
 	Rate int
 }
 
 type Salary struct {
 	AnnualPay int
 }
 
 type Manager struct {
    //multi embedded types are allowed
 	Employee
 	Salary
 	DirectReports []Employee
 }
 
 func main() {
    // assignment requires specifying the embedded type
 	m := Manager{
 		Employee: Employee{
 			Name: "Tim McDleen",
 			ID:   "8675309",
 		},
 	}
 
    // the "promotion" is just a syntactic shortcut during invocation 
 	fmt.Println(m.Description())
    // for this
    fmt.Println(m.Employee.Description())
 }
----

----
Interfaces
 - the true gem of this lang
 - only abstract type in Go
 - unimplemented methods are allowed on the type's declaration
 - are implemented implicitly
  - allows for type-safe duck-typing
 - are typically defined as agent-nouns
  - e.g. fmt.Stringer, io.Reader, http.Handler, json.Marshaler
 - the flexibility of interfaces makes it so that every 
   input _should_ be an interface
  - while the output _should_ be a struct
 - is on the stack as two pointers 
  - one is the underlying type
  - the other is the underlying value
 
 //an abstract type which has one method named "PrintThis"
 type SomeInterface interface {
 	PrintThis(string) string
 }
 
 //a concrete type 
 type SomeConcreteType struct{}
 
 //at this point SomeConcreteType IS-A implementation of SomeInterface
 func (lp SomeConcreteType) PrintThis(data string) string {
 	return fmt.Sprintf("---%s", data)
 }
 
 //a container which HAS-A of "SomeInterface"
 type MyHasAType struct {
 	MyProcess SomeInterface
 }
 
 func main() {
 	mine := MyHasAType{
 		//however, we can assign it to this since it implements "PrintThis"
 		MyProcess: SomeConcreteType{},
 	}
 	fmt.Println(mine.MyProcess.PrintThis("something"))
 }
----

----
Embedding Interfaces
 - just like embedding structs, interfaces can be embedded

 type MyBegin interface {
    Open()
 }
 
 type MyEnd interface {
    Close()
 }
 
 type MyBeginAndEnd interface {
    MyBegin
    MyEnd
 }
----

----
Interface As Variant
 - a way to say that a variable could store _anything_
 - to then assert its type is a runtime-only known fact
  - a type-conversion is known at compile time
  - type assertions can only be applied, therefore, to interfaces
 
 //variable declaration for anything
 type Name struct {
 	FirstName string
 	LastName  string
 }
 
 func main() {
 	var i interface{}
 	i = 20
 	i = "word"
 	i = Name{"Tim", "McDleen"}
 
 	//if you are know the concrete type assertion will work
 	i2 := i.(Name)
 
    //this will cause a "Panic" if you get it wrong
 	fmt.Println(i2.FirstName, i2.LastName)
 }
----

----
Error Handling
 - is based around returned errors
  - not thrown exceptions
 - is based on an interface type named "error"
  - this interface only has one method name Error 
    which has no-args and returns a string
 - package-level defined errors are called Sentinel Errors
  - they typically have a naming convention starting with 'Err'
  - these are "self-evident" like 'EOF' 
    and require no contextual explanation
 
 - may be instantiated using errors package's New factory method
 errors.New("my error message")
 
 - or with formatting using fmt package
 fmt.Errorf("%d is out of range", i)
 
 - closest thing to the idea of "throwing an exception" is 'panic'
  - invoking 'panic' will produce a stack-trace
  - once a 'panic' happens only 'defer' blocks will executed
  - its not the same as an exception
  - the running program is expected to shutdown
  
 if err != null {
    panic(err)
 }
 
 - closest thing to the idea of "catch" is 'recover'
  - must be called within the body of a defer block
  - 'recover' is intended for graceful shutdown
  - panics should not escape an api
 
 func errHandlingExample(i int) {
    defer func() {
        if v := recover(); v != nil {
            //this is like the body of a catch block
            fmt.Println(v)
        }
    }()
    //any panic(s) happening here will invoke the 
    // defer declared above
 }
 
 - errors can be checked against 'nil'
 if err != nil {
    fmt.Println(err)
    os.Exit(1)
 }
----
 
----
Custom Error Types 
 - a custom error using explicit status
 - the return type of any function\method should still 
   be the "error" type and not this custom "LoginStatusErr"
 
 //a custom int type 
 type LoginCode int
 
 //an "enum" of the various status of said type
 const (
 	InvalidLogin status = iota + 1
 	NotFound
 )
 
 //another type to hold the status and a message
 type LoginStatusErr struct {
 	Status Status
 	Message string
 }
 
 //implement this method, then this IS-A "error" type
 func (se LoginStatusErr) Error() string {
 	return se.Message
 }
 
 //return type is always "error" 
 func MakeItError(flag bool) error {
 
    //nor should the declaration be the custom error's type
    var genErr error
    if flag {
        genErr = LoginStatusErr {
            Status: NotFound,
        }
    }
    return genErr
 }
----

----
Error Nesting
 - like in .NET's concept of inner-exception
 - is esoteric use of factory methods in the "errors" & "fmt" packages
  - the use of the "%w" within the fmt.Errorf("in Somemethod: %w", err)
 
 f, err = os.Open("somefile.txt")
 if err != nil {
    //this concat's the error messages and "wraps" one error into another
    return fmt.Errorf("sum ting wong: %w", err)
 }
 
 //the "Unwrap" method will return the error within an error
 wrappedErr := errors.Unwrap(err); 
 if wrappedErr != nil {
    fmt.Println(wrappedErr)
 }
----

----
Error Type Checking 
 - uses methods within the "error" package
 
 - "errors.Is" will check if an error is a specific 
    instance or has specific values
  - test is applied to ever wrapped error therein
 
 //first arg is the error, second is the type
 errors.Is(err, os.ErrNotExist)
 
 - "errors.As" will check if an error is a specific type
  - test is applied to ever wrapped error therein
 
 //using a declared, "anything with this method" trick
 var someVariant interface {
    Code() int
 }
 
 //first arg is the error, second is a pointer to the decl
 if errors.As(err, &someVariant) {
    fmt.Println(coder.Code())
 }
----

----
Go Library Mgmt
 - Go is organized around 
  - repositories:  common meaning
  - modules: the root folder of a repo
  - packages: the subdivision of a module
 
 - typical practice is to have one-module-to-one-repo
  - a single module may have multiple applications
  - along with multiple packages
  
 - a module is defined by a top-level file named go.mod
  - this file will name the module along with dependencies and such
  - the first line will define the modules root-path
   - packages are imported by this root plus relative path
  - also includes a minimum version of Go 
  - the optional declarations are: 
   - 'require' for dependent modules
   - 'replace' for overriding the location of dependent modules
   - 'exclude' for preventing a specific version of the module 
      from being used
  
  module github.com/nofuture
  
  go 1.16
  
  require (
    github.com/somedependent/thing
  )

 - installed modules will be at the $env:GOPATH\pkg\mod
     
 - to create a module the go command line is used
  - this will simply create the .mod file
  - nothing is created on github
  - no directories are created either
  - this name will be the root-path for all packages
 go mod init github.com/nofuture
----

----
Package Declaration
 - is declared as the first line of the code-file
 - is keyword "package"
 - the first line is called "the package clause"
 - every file in a directory must have the same package clause
 - the package clause determines its name, not the directory name
  - its expected that the package clause always matches the directory
 - circular dependencies are not allowed 
  - if package A imports package B directly or indirectly
    then package B cannot import package A directly or indirectly

 package myPackage 
 
 import (
    //only package in the standard lib are imported like this
    "fmt"
    
    //the "github.com/nofuture" is the module's root-path
    // declared in the go.mod file
    "github.com/nofuture/math"
    //is possible to alias a package's name
    // aliasing a package with "_" will cause its "init" function to execute
    nfUtil "github.com/nofuture/util"
 )
 
 func DoStuff(i int) string {
    return fmt.Sprintf("The number is %d", i)
 }
 
 - the "main" package is the starting point
  - this follows a naming convention
  
 package main
 
 import (
    "fmt"
    "github.com/nofuture/mypackage"
 )
 
 func main() {
    num := 2
    output := mypackage.DoStuff(num)
    fmt.Println(output)
 }
----

----
Package Organization
 - no real paradigm 
 - should be consistent 
 - should be transitive in that how it works
   matches how its organized
 - special named "init" with no-args and no return type
   will run once the first time a package is referenced
  - its use should be avoided
  - multiple "init" functions _could_ be declared within
    a single package 
  
 - package naming should be verb-noun'esque
  - e.g. avoid a "util" package 
  - contain functionality within descriptive package names
  
 - hexagonal arch 
  - applications are contained in top-lvl "cmd" folder
   - each folder within the cmd folder is for a single application
  - all packages are contained in top-lvl "pkg" folder
 
 - package documentation is based on comments
  - requires a line comment(s) just above the declared symbol
  - line breaks in doc will be blank line comments in code
  - formatting will get preserved 
  
 // Package money provides currency related functionality
 package money
 
 // Money represents an amount and a currency type
 type Money struct {
 	Value    float32
 	Currency string
 }
 
 // ToCurrency converts one currency into another
 //
 // More information here
 func (m Money) ToCurrency(to string) (Money, error) {
 	var nm = Money{
 		Value:    m.Value,
 		Currency: to,
 	}
 	return nm, nil
 }
----

----
Package Versioning
 - upon multiple dependencies having, themselves, a 
   dependency on another module with different versions.
  - Go will import the higher of the two versions 
    since it considers that version as the minimum
 - when a module has a major release its root-path must
   be appended with the "/v2" (for major release '2')
   
  module github.com/nofuture/v2

 - no central repo but a central kinda wiki is 
  available at pkg.go.dev
  
 - Go uses proxy servers to store dependencies and
   has a database of each dependencies check-sum
  - invocation of 'go build', 'go test' or 'go get'
    will verify dependencies check-sum
----

----
Concurrency
 - part of Go's primary implementation
 - is called "Goroutines"
 - intended to take advantage of multi-core processors 
 - works off features of
  - go routines
  - channels
  - 'select' keyword
 
 - Go's concurrency model 
  - has its own scheduler
  - has its own runtime managed threads
   - go threads will queue into OS threads
    - many go threads are being context-switched atop OS threads
    - OS threads are being reused by the scheduler
   - limit of OS threads is number of processor's cores
   - go threads are 2KB init and grow as needed
   - communicate via Go's channels
  
 package main
 
 import (
 	"fmt"
 	"log"
 	"net/http"
 	"os"
 	"sync"
 )
 
 //global wait-group
 var wg sync.WaitGroup
 
 //an mutex for thread safety
 var mut sync.Mutex
 
 func sendRequest(url string) {
 	//this is the counterpart of "wg.Add(1)"
 	defer wg.Done()
 
 	res, err := http.Get(url)
 	if err != nil {
 		panic(err)
 	}
 
 	//this is getting a lock - threads will line-and-park here waiting for a turn
 	mut.Lock()
 
 	//part of the function's cleanup is to release the lock
    // last-in-first rule for defer means this runs before the defer at the top
 	defer mut.Unlock()
 
 	//this is what we want thread-locking around
 	fmt.Printf("[%d] %s\n", res.StatusCode, url)
 
 }
 
 func main() {
 	if len(os.Args) < 2 {
 		log.Fatalln("Usage: go run main.go <url1> <url2> ... <urlN>")
 	}
 
 	for _, url := range os.Args[1:] {
 
 		//using the 'go' keyword to launch a managed thread
 		go sendRequest("https://" + url)
 
 		//increment the wait group
 		wg.Add(1)
 	}
 
 	//make the main thread wait for all the other threads to finish
 	wg.Wait()
 }
 
 //Measure-Command {Invoke-Expression "go run main.go google.com github.com quora.com bing.com youtube.com heroku.com dev.to twitter.com facebook.com gitlab.com"}
 
 //Benchmark
 // 1 | TotalSeconds      : 5.956342
 // 2 | TotalSeconds      : 1.5620971
----

----
Channels
 - the manner in which Goroutines communicate
 - the Goroutine that writes to a channel is responsible for 
   closing it
 - comes in two kinds
  - unbuffered: which are blocking
  - buffered: do not block
 - use global "make" and "close" functions to open and close
 - have one operator to push and pop values 
  - send-channel operator (write)
   - "<-" is placed to the right of the channel variable
  - receive-channel operator (read)
   - "<-" is placed to the left of the channel variable
 
 package main
 
 import "fmt"
 
 func SendValue(c chan string) {
 
 	//use the send-channel operator
 	c <- "hello world"
 }
 
 func main() {
 	//instantiate unbuffered channel
 	values := make(chan string)
 
 	//close the channel upon exit of main
 	defer close(values)
 
 	//unbuffered channel are blocking operations
 	go SendValue(values)
 
 	//use the receive-channel operator
 	value := <-values
 
 	fmt.Println(value)
 }
 
 - to read from a channel which may be closed 
  - use the "comma ok idiom"
  - if 'ok' is true, the channel is open
 myValue, ok <- myChannel
----

----
Channels 'select' Statement
 - a unique syntax for go's concurrency
 - intended to keep developer from favoring one 
   channel operation over another
  - this is a CS concept called "starvation"
 - when multiple channels may be read from at the same
   time
  - the go runtime will select one of the readable cases
    at random
 
 select {
 //read from channel 'ch00' and write its value to 'v'
 case v := <-ch00
    fmt.Println(v)
 // read from channel 'ch01' and write its value to 'v'
 case v := <-ch01
    fmt.Println(v)
 // write the value of 'x' to channel 'ch02'
 case ch02 <- x
    fmt.Println("wrote to channel 2",x)
 //read and gc from channel 'ch03'
 case <-ch03
    fmt.Println("read from ch03 and ignored it")
 }
----
 
