----
Notes Go
Learning Go
First Edition And Idiomatic Approach to Real-World Go Programming
by Jon Bodner
O'Reilly Media 
978-1-492-07721-3
----

----
Overview
 - Go does not have:
  - inheritance
  - generics
  - function overloading
  - operator overloading
  - pattern matching
  - named parameters
  - exceptions


 - Go does have Pointers
 - Go will compile its own runtime into 
   every executable
  - dotnet v 5.0.403 "Hello World" is 123KB
  - go v 1.17.3 "Hello World" is 1881KB
----

----
Basics
 - download the installer from 
  https://go.dev/dl/
  
 - the installer adds the necessary environment variables
  
 - to explicitly set the GOPATH environment variable
 [System.Environment]::SetEnvironmentVariable("GOPATH",(Join-Path $env:USERPROFILE "go") ,"Machine")

 - get installed version
 go version

 - get go environment settings
 go env
 
 - to run a go file like a script
 go run myGoFile.go
 
 - to build a go .exe
 go build myGoFile.go

 - get third party components
  - this will install a .exe in \bin folder of you GOPATH
  - Go seems to have no problems with corporate firewalls (?)
 go install github.com/rakyll/hey@latest
 
 - in Go the formatting is explicit 
  - best-practices at https://go.dev/doc/effective_go
 - the Go compiler will add semi-colons to all statements
 - the dev has to explicitly call a formatting command prior to compiling
 go fmt
 
 - another code scanning command used to find things like
  - wrong number of parameters
  - unused variables with assignment
  - run the vetting tool across your entire project 
 go vet ./...
 
 - third party linting tool 
  - one-time install command
 go install golang.org/x/lint/golint@latest
 
  - run the linter across your entire project
 golint ./...
----

----
Go Module Basics
 - modules are the main domain container 
 - a module is defined by a top-level file named go.mod
  - this file will name the module along with dependencies and such
  - the first line will define the modules path
module github.com/nofuture/somejunk

 - installed modules will be at the $env:GOPATH\pkg\mod
  - within this folder the folder structure will match
    the modules definitional structure (like Java packages)
    
 - to create a module the go command line is used
 
 go mod init github.com/nofuture/somejunk 
----

----
Go Primitives
 - integer
  - has the common 8 types (4 signed, 4 unsigned)
  - can be written in decimal, binary, octal or hex
  - binary is prefixed with 0b
  - octal is prefixed with 0o
  - hex is prefixed with 0x
  - go allows for underscore to be present 
    in integer literal for readability
   - for example, speed of light m/s
  299_792_458

 - floats
  - can be written in decimal or hex
  - actual types are float32 and float64
  - scientific notation is allowed
   - for example Avogadoros Number
  6.022e23
  
 - chars
  - these are called 'runes' in Go
  - uses single quotes like C#
  - are Unicode 
   - literals can be 8, 16 or 32 bit
  '\x61' '\u0061' '\U00000061'
  
 - strings
  - literals are enclosed in double quotes
  - verbatim strings are enclosed in back-tick (0x61)
  `here is my 
  Here-String in go`
  
 - booleans
  - same as elsewhere
  - literal values are keywords 'true' and 'false'
  - default value is false
----

----
Go Operators

 - arithmetic 
  + - * / %
  
 - compound assignment ops
 += -= *= /= %=

 - comparison ops
 == != > >= < <=

 - bitwise ops
 << >> & | ^ &^ (logical AND NOT)
 
 - empty and nothing
  - Go has 'nil' and 'null'
  - nil is an identifier that lacks a 
    value for some known type

 - global builtin functions
  - len, various uses for getting a "length"
  - append, used to extend a slice
  - etc.
  
 - variadic parameters 
  - uses the three-dot convention '...'
----

----
Variable Decl and Assignment
 - most explicit declaration and assignment
 var x int = 10
 
 - implicit type 
 var x = 10
 
 - declaration without assignment
 var int x
 
 - decomp decl and assignment
 var x, y int = 10, 20
 
 - implicit decomp decl and assignment
 var x, y = 10, "foo"
 
 - unique concept called declaration list
 var (
     x    int
     y        = 20
     z    int = 30
     d, e     = 40, "bar"
     f, g string
 )
 
 - within the body of a function a 
   syntax short-hand is ":="
 x := 10
 
 - constants are the same as in C#
  - if the constant is being used mathematically
    it should be declared implicitly so to avoid 
    casting
 const magicNumber = 42;
 
 - arrays
  - Go considers the length of an array as part of 
    its type
   - arrays of different lengths cannot be converted
 var x = [3]int
 var y = [3]int{2, 4, 6}
 
 - slices
  - Go has this idea as what most langs call an array
 var z = []int{10, 20, 30}
 
  - can specify indices in a slice-literal
 var m = []int{1, 5: 4, 6, 10: 100, 15}
   - the following would make the array
     [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]
     
  - to expand an array the global 'append' 
    function is used  
 var c = []int
 c = append(c, 10) 
 d = []int{88, 89, 90}
 c = append(c, d...)
   - this will append all of d to the tail of c
   
  - use the global 'cap' function to get 
    a slice's total capacity
  fmt.Println(cap(c))
  
  - use global 'make' function to init 
    a slice with an explicit size
  f := make([]int, 5)
   - makes a new slice with 'cap' of 5
 
  - a zero-length slice is not nil
 v := []int{}
----

----
Array Slices
 - a slice will be another variable to some
   part of an existing array
 - the memory is the same only the ref changes
 
 var x = []int{1, 2, 3, 4}
 y := x[1:3]
 z := x[:] //another ref to the same 
 
 - to terminate the shared memory of a 
   slice-of-a-slice, use this three-part 
   slice expression
  - the final param terminates where the 
    shared part by index
 m := x[2:4:2] 
 
 - the builtin 'copy' will make an
   independent copy
  - the different lengths does not matter
 x := []int{1, 2, 3, 4}
 y := make([]int, 2)
 //first param is dest, second is source
 // 'n' is the number of elements copied
 n := copy(y, x)
----

----
Conventions
 - variable names are camelCase
 
 
 
 
  
 
 

 
 