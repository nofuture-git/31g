Notes Linear Algebra

----
Practical Linear Algebra, 3rd Edition
By: Gerald Farin; Dianne Hansford
Publisher: CRC Press
Pub. Date: August 19, 2013
Web ISBN-13: 978-1-4822-1128-3
Web ISBN-13: 978-1-4665-7959-0
Print ISBN-10: 1-4665-7956-0
Web ISBN-10: 1-4665-7959-5
Print ISBN-13: 978-1-4665-7956-9
Web ISBN-10: 1-4822-1128-9
Web ISBN-13: 978-1-4665-7958-3
Pages in Print Edition: 514
----

----
https://www.math.uh.edu/~jmorgan/Math6397/day13/LinearAlgebraR-Handout.pdf
----

----
R in Action, Second Edition
Data analysis and graphics with R
Robert I. Kabacoff
May 2015 ISBN 9781617291388 608 pages printed in black & white
----

----
R Builtins
 - Numeric functions
 abs(x)	absolute value
 sqrt(x)	square root
 ceiling(x)	ceiling(3.475) is 4
 floor(x)	floor(3.475) is 3
 trunc(x)	trunc(5.99) is 5
 round(x, digits=n)	round(3.475, digits=2) is 3.48
 signif(x, digits=n)	signif(3.475, digits=2) is 3.5
 cos(x), sin(x), tan(x)	also acos(x), cosh(x), acosh(x), etc.
 log(x)	natural logarithm
 log10(x)	common logarithm
 exp(x)	e^x
 
 - Logical 
  < 	less than
  <=  	less than or equal to
  > 	greater than
  >=	greater than or equal to
  ==	exactly equal to
  !=	not equal to
  !x	Not x
  x | y	x OR y
  x & y	x AND y 
  isTRUE(x)	test if X is TRUE

  isTRUE(2 > 1 | 1/0) #is short-circuit logical ops
  
 -Other  
 seq(start,end[,step]) gen' stepped sequences 
 c(1:10) gen' single sequences
 
----

----
Basics with R
 #define a vector
 a <- c(1,3,2)
 b <- c(2,8,9)
 
 #assignment can work both ways
 c(1,3,2) -> a  
 c(2,8,9) -> b
 
 #multiple statement on single line are ; sep'ed
 c(1,3,2) -> a; b <- c(2,8,9)
 
 #transpose 
 t(a)

 
 #scalar multiplication
 7*a
 
 #sum of vectors
 a+b
 
 #inner product
 sum(a*b)
 
 #vector length (e.g |a|)
 sqrt(sum(a*a))
 
 #repeat 0,1 vector
 rep(0,5)
 rep(1,5)
 
 #orthogonal vector have inner product of zero
 v = c(0,5)
 w = c(3,0)
 sum(v*w)  #equals zero
 
 #define a matrix
 #df are read column-by-column 
 A <- matrix(c(1,3,2,2,8,9), ncol = 3)
 #set to read row-by-row
 B <- matrix(c(5, 8, 3, 4, 2, 7), ncol = 3, byrow = T)
  
 #scalar multiplication
 7*A
 
 #transpose matrix
 t(A)
 
 #matrix addition
 A + B
 
 #column-vector multiplication
 b <- c(5,8)
 A %*% a
 
 #matrix multiplication
 #A as r X c and B as c X t, AB is r X t matrix
 A <- matrix(c(1,3,2,2,8,9), ncol=2)
 B <- matrix(c(5,8,4,2), ncol = 2)
 A %*% B
 
 #identity matrix
 diag(1,3)
 
 #find inverse
 A <- matrix(c(1,3,2,4), ncol=2, byrow=T)
 B <- solve(A)
 A %*% B       #identity matrix
 
 #find determinent
 A <- matrix(c(1,0,5,1), ncol=2)
 B <- det(A)
 
 #find eigen values, vectors
 # - the result is a type with two props
 # - ev$val for eigen values
 # - ev$vec for eigen vectors
 ev <- eigen(A)
 
 #user defined function (in-line)
 myNormalForm <- function(x1, x2) -2*x1 + 4*x2 - 4
 
 #user defined function(multi-line)
 # - written in a separate UTF8 file
 # - then imported into console 
 #  - using 'source("path-to-file")'
 #  - path-separator is unix-style /
 
 vLen <- function(a) {
    sqrt(sum(a*a))
 }
 source("C:/MyR/UserFunctions/LinearAlgebra.r")
 vLen(c(5,4)) #6.403124
 
 #other usefull builtin
 length(a); mean(a); min(a); max(a); var(a) #var is for variance
 ls()  # display all the variables defined so far in the console.
 rm(a) # gc a variable 
 sink("C:/MyR/MyOutput/output.txt") #will route all output to file
 sink() #sets output back to console.
 help("[[") #gets help on builtin symbols (displays in browser)
----

----
Points & Vectors
 - most basic 2D a point is two coords
 - three or more points are collinear when 
   they all lie on a single line
 - two points are collinear since it takes 
   two points to form a line.
 p = [p1,p2]
 q = p + v
 [q1,q2] = [p1,p2] + [v1,v2] = [p1 + v1, p2 + v2]
 v = q - p
 [v1,v2] = [q1,q2] - [p1,p2] = [q1 - p1, q2 - p2]
 
 - vector is a difference of two points
   which describes a direction and distance
  - the components of v is v1 and v2 which indicate
    a rise & run from point p
  - two vectors are equal if they have the same
    component values just as two points are equal
	if they have the same coords
  - a vectors components are called a 'tail' and 'head'
  
 - points and vectors are different geometric entities
  - distinguishing them it to achieve geometric constructs
    that are coordinate-independent.
  - coordinate-independent constructs are manipulations 
    applied to geometric objects that produce the same 
    result regardless of the location of the coordinate 
    origin.
  
 - in practice:
  - subtracting to points yields a vector
  - adding or subtracting two vectors yields another
    vector
  - multiplying by a scalar is called scaling.
    The result s*v adjusts the length by the scaling
	factor
	- the direction is unchanged if s is greater-than 0
	- the direction is reversed if s is less-than 0
  - adding a vector to a point yields another point

  - a 'well-defined' operation is one which is coordinate 
    independent
  - scaling a point (s*p) is not well-defined
  - scaling a vector (s*v) is well-defined
  - adding two points (p+q) is not well-defined since
    it is dependent on the coordinate origin
  - a vector-field is one where each point is 
    assigned to a vector 
  - moving a continuous field into a vector-field
    is called discretizing - taking some sample of
	points and assigning each a vector
	
 - a Matrix is a map of vectors to vectors
----

----
Vector Length
 - may represent distance, velocity or acceleration
 - length of a vector is called magnitude
 - since a vector's components are the rise & run
   the vector's length may be assigned as the 
   hypotenuse of a right triangle
 - this is named the Euclidean norm  
   |V|^2 = v1^2 + v2^2
   |V| = sqrt(v1^2 + v2^2)
 - a normalized vector has a unit length of one
   |W| = 1
  - normalized vectors are also known as unit vectors
  - not every vector is a normalized one
 - to normalize a vector is divide each component by 
   Euclidean norm
   W = v/|V|
   
   - example, not a normalized vector
   v = [3,7]
  |V| = sqrt(3^2 + 7^2)
  |V| = 7.615773106
   W = [3/7.615773106, 7/7.615773106]
   W = [0.3939192986, 0.91914503]
   
  - example, a normalized vector
   v = [5,0]
  |V| = sqrt(5^2,0^2)
  |V| = 5
   W = [5/5, 0/5]
   W = [1, 0]
   
 - the distance between two points is the
   Euclidean norm of the vector of the two points 
   q = [-1,2]
   p = [1,0]
  q-p  = [-1-1, 2-0] = [-2,2]
 |q-p| = sqrt(-2^2 + 2^2)
 |q-p| = 2.828427125
----

----
Combining Points
 - although not well-defined there is a way to 
   combine two points
  -given two points p and q, v = q-p, t is a scaler
 r = p + t*v
 r = p + t*(q-p) 
 r = p + tq - tp
 r = p - tp + tq
 r = (1-t)*p + tq
      t = |r-p| / (|r-p| + |q-r|) 
  (1-t) = |q-r| / (|r-p| + |q-r|)
  
 - example
  p = [2,4], r = [6.5,7] q = [8,8]
  r = (1-t)*p + tq
  [6.5,7] = (1-t)*[2,4] + t*[8,8]
  
  |r-p| = |[6.5 - 2, 7 - 4]|
  |r-p| = |[4.5, 3]|
  |r-p| = sqrt(4.5^2 + 3^2)
  |r-p| = 5.408326913
  
  |q-r| = |[8 - 6.5, 8 - 7]|
  |q-r| = |[1.5, 1]|
  |q-r| = sqrt(1.5^2 + 1^2)
  |q-r| = 1.802775638
  
  |r-p| + |q-r| = 5.408326913 + 1.802775638
  |r-p| + |q-r| = 7.211102551
  
  t = |r-p| / (|r-p| + |q-r|) 
  t = 5.408326913 / 7.211102551
  t = 0.75
  
 (1-t) = |q-r| / (|r-p| + |q-r|) 
 (1-t) = 1.802775638 / 7.211102551
 (1-t) = 0.25
----

----
Dot Product
 - concerns the two vectors 
  - are they the same vector
  - are they perpendicular 
  - what angle to they form
 
 |v - w|^2 = |v|^2 + |w|^2
 (v1 - w1)^2 + (v2 - w2)^2 = (v1^2 + v2^2) + (w1^2 + w2^2)
  -binomial expansion
 (v1^2 - 2*v1*w1 + w1^2)+(v2^2 - 2*v2*w2 +w2^2) = (v1^2 + v2^2) + (w1^2 + w2^2)
 (v1^2 - 2*v1*w1 + w1^2)+(v2^2 - 2*v2*w2 +w2^2) - (v1^2 + v2^2) - (w1^2 + w2^2) = 0
  v1^2 - 2*v1*w1 + w1^2 + v2^2 - 2*v2*w2 +w2^2  + -v1^2 +  -v2^2 + -w1^2 + -w2^2 = 0
   (v1*w1) + (v2*w2) = 0
      v * w = 0
 
 - is then used to define the cosine of two vectors
        w   
       7
      /.
     / .
    /  .
   /   .
  /    .
 /)____.___> v
 -solve for the angle by
  cosθ = v*w / |v|*|w|
----

----
Orthogonal projection
 - the orthogonal project of w onto v is defined as
 
  u = ((v * w)/|v|^2) * v
 - using this the vector w can be decomposed into 
   two perpendicular vectors
  
  u┴ = w - ((v * w)/|v|^2) * v
----

----
Other vector rules
 - Cauchy-Schwartz inequality
 - used for the study of more genearl vector spaces
 (v * w)^2 <= |v|^2 * |w|^2
 
 - triangle inequality
 |v + w| <= |v| + |w|
 
 - barycentric coordinates 
  - interpreting vector v as the diff 
    between points q and p 
 v = q - p	
----

----
Linear Combination
 - two vectors are parallel they are called
    linearly dependent
 - not being the case is called
    linearly independent
 
 - linear combination is taking two 
   linearly independent vectors to make 
   a new vector
 u = r*v + s*w
 
 a1 <- c(2,1)
 a2 <- c(-2,4)
 v <- c(0.5,1)
  
 myLinearCombo <- v[1] * a1 + v[2] * a2
 
 - this is easier in using a matrix
 A <- matrix(c(2,1,-2,4), ncol = 2)
 myLinearCombo <- A %*% v
----

----
Lines defined
 - different ways to specify a line geometrically
  - two points on a single line
  - one point and one vector on a line
  - one point and one vector perpendicular to the line
 - likewise, there are different was to specify a line
   mathematically
  - parametric
  - implicit
  - explicit
  
 - Parametric equation of a line
  - where p ϵ E² and v ϵ R² (whatever that means)
  l(t) = p + tv  
   v = q - p (barycentric coords)
  l(t) = (1 - t)p + tq  (this form is aka linear interpolation)
  - can be used to find points on a line given two points
  
 - Implicit equation of a line
  a*x1 + b*x2 + c = 0
   a = a1
   b = a2
   c = a1*p1 - a2*p2
   
  - solve for a
  p <- t(c(2,2)); q <- t(c(6,4))
  v <- q - p
  # a = [-v2, v1]
  
  a <- t(c(-1*v[1,2], v[1,1]))
  #a = [-2,4]
   
  - solve for c
  c <- -1 * a[1,1] * p[1,1] - a[1,2] * p[1,2]
  #c = -4
   
  - implicit form is
   implicitForm <- function(x1,x2) -2*x1 + 4*x2 - 4
  - this can be used to determine if a point is on a line
   implicitForm(2,2) #0
  - to test equality this should because of floating point errors
  #d = (a1*x1 + a2*x2 + c) / |a|
  isOnLine <- function(x1,x2) (normalForm(x1, x2)) / vLen(a)
  
 - Explicit equation of a line
  x2 = ~a * x1 + ~b
  - where  ~a is -a/b and ~b = -c/b
  - this the classic form with intercept and slope
  - ~a is the slope (rise/run) 
   - slope is formally defined as tan(θ)
   - problem with explicit form is flat lines
     have and infinite slope
----
   
----
Line Equation conversion
 - Parametric to Implicit
 l: l(t) = p + tv        parametric
 l: a*x1 + bx2 + c = 0   implicit
   a = [-v2, v1]
   c = -(a1*p1 + a2*p2)
   
 - Implicit to Parametric 
 l: a*x1 + bx2 + c = 0   implicit
 l: l(t) = p + tv        parametric
   v = [b, -a]
   p = [-c/a,0] -or- [0,-c/b]
      choose by whichever is greatest
	   abs(a) > abs(b), choose [-c/a,0]
	   abs(a) < abs(b), choose [0,-c/b]
----

----
Distance of a Point to a Line
 - given any point (r) and line (l)
   how far is r from l
   
 d = (a * (r - p)) / |a|
 
 - implicit eq form
  l: 4 * x1 + 2 * x2 - 8
  r: [5,3]
  
  l <- c(4,2)
  c <- -8
  r <- c(5,3)
  
  d = (sum(l * r) + c) / vLen(l)
----

----
Foot of a given point
 - given some line (l) and some point (r)
   which point on (l) is closest to (r) 
   known as (q)

  t = (v * (r - p)) / (vLen(v))^2
  q = p + t * v
  
  - parameteric eq form
   l(t) = p + t * v
    l: = [0,1] + t * [0,2]
    r: [3,4]
   
  p <- c(0,1)
  v <- c(0,2)
  r <- c(3,4)
  
  t <- (v * (r -p)) / vLen(v)^2
  q <- p + t * v
----

----
Line intersect points
 - calc form for:
  - parametric & implicit
  - both implicit
  - both parametric
----

----
Parametric & Implicit Solve for intersect 
 line_1: l(t) = p + t * v
 line_2: a*x1 + b*x2 + c = 0
 
 - find the parameter (t) with respect 
   to line_1
 - plug-in line1 into line2
  a * [p1 + t * v1] + b * [p2 + t * v2] + c = 0
 - solve for t
 
  t = (-c - a * p1 - b* p2) / (a * v1 + b * v2)
 - if the denominator is zero the two lines are 
   parallel and never intersect
 - check for parallel before solving using 
   by calc cosine of a * v
  cosθ = a*v / vLen(a) * vLen(v)
   - computational tolerance around cos(0.1) 
     and cos(0.5)
 - furthermore, these may be the same lines 
  d = (a*p1 + b*p2 + c) / vLen(a)
   - are the same line if (d) equals zero
 
  -example
   line_1: l(t) = [0,3] + t * [-2,-1]
   line_2: 2*x1 + x2 - 8 = 0
 
  p <- c(0,3)
  v <- c(-2,-1)
  ab <- c(2,1)
  c <- -8
  
  myDenom <- sum(ab * v) #no eq zero
  t <- (-1*c - sum(ab * p)) / myDemon
  
  #use t to solve line_1
  myIntersect <- p + t * v # [2,4]
----

----
Both Parametric Solve for intersect 
 line_1: l1(t) = p + t * v
 line_2: l2(t) = q + s * w
 
 - need to solve so that
  p + t * v = q + s * w
  - rewritten as
   t*v - s*w = q - p
  
 - example:
  line_1: l1(t) = [0,3] + t * [-2,-1]
  line_2: l2(t) = [4,0] + s * [-1, 2]
  
  p <- c(0,3)
  v <- c(-2,-1)
  q <- c(4,0)
  w <- c(-1,2)
 
  #the text gives no explaination for 
  # how we arrive at these values
  t <- -1
  s <- 2
----

----
Both Implicit Solve for intersect 
 line_1: a0*x1 + b0*x2 + c0 = 0
 line_2: a1*x1 + b1*x2 + c1 = 0
 
 - example
 line_1: 1 * x1 - 2 * x2 + 6 = 0
 line_2: 2 * x1 + 1 * x2 - 8 = 0
 
  #the text gives no explaination for 
  # how we arrive at these values
  - intersect x = [2,4]
----

----
Convert degrees to radians
 - R only works in radians, not degrees
 - Circumference = 2*pi*r 
    where r is radius
 - want to work as r = 1
   C = 2 *pi, which is 360 degrees
 - so 180 degrees is just pi
 - conversion is thus where (a)
   is degrees
   
   (a / 1) * (pi / 180)
----

----
Matrix Laws & Names
 - not commutative multiplication
   AB != BA
   
 - associative multiplication
  A*(B*C) = (A*B)*C
  (a*b)*C = a*(b*C)
  a*(B*C) = (a*B)*C = B*(a*C)
  
 - distributive law
  A*(B + C) = A*B + A*C
  (B + C)*A = B*A + C*A
  A*v + B*v = (A + B)*v
  [A + B]ᵀ = Aᵀ + Bᵀ
  A*(u + v) = A*u + A*v
  
 - commutative addition
  A + B = B + A
  
 - associative addition
  A + (B + C) = (A + B) + C
  
 - symmetric matrix is 
   A = Aᵀ
 - dyadic matrix
   A*Aᵀ
 - idempotent matrix
   A = A*A
 
 - other multiplication rules
  (A*B)ᵀ = Bᵀ*Aᵀ
  det(A * B) = det(A) * det(B)
 
 - exponent rules
   A^(r+s) = A^r * A^s
   A^(r*s) = (A^r)^s
   A^0 = I

 - inversion rules
  A^-1*A = I
  A*A^-1 = I
  I^-1 = I
 (A^-1)^-1 = A
 (A^-1)ᵀ = (Aᵀ)^-1
   
----

----   
Reflection 
 - is like flipping & rotating on an axis
  -example
   myR <- matrix(c(1,0,0,-1), ncol=2)
   v <- c(2,4)
   myR %*% v # [2,-4], flipped along x-axis 
           # when c(2,4) is thought of as 
	       # x = 2, y = 4
   myR <- matrix(c(0,1,1,0), ncol=2)
   myR %*% v # [4,2], x & y swapped places
   
   myR <- matrix(c(-1,0,0,-1), ncol=2)
   myR %*% v # [-2,-4] 180 rotation
   
 - rotation matrix is given as where (a)
   is the desired angle of rotation
  
  R = [ [cos(a), -sin(a)],
        [sin(a), cos(a) ] ]
  
  a <- degrees2Radians(45)
  myR <- matrix(c(cos(a),sin(a),-1*sin(a),cos(a)),ncol=2)
----

----
Shears
 - tilt like how italic fonts look to regular
 
 v' = [ [   1,   0],  * [v1,  = [v1,
        [-v2/v1, 1] ]    v2]     0]
		
 - example
 v <- c(2,5)
 vMatrix <- matrix(c(1,(-1*v[2]/v[1]),0,1), ncol=2)
 vTick = vMatrix %*% v # 2,0
----

----
Projections
 - like sunlight casting shadows
 - parallel projections are having all vectors
   projected in a parallel direction
 - when the angle of incidence is 90 degrees
   then its an orthogonal projection
 - otherwise known as an oblique projection
 
 - example
  # a 45 degree rotation
  ui <- 1/sqrt(2)
  u <- matrix(c(ui, ui),ncol=1)
  #defines projection matrix
  A <- u %*% t(u)
  
  #projection of v by 45 degrees
  v <- c(1,2)
  vTick <- A %*% v #1.5, 1.5
----

----
Linear Maps and Area
 - getting the area given two vectors
  a1 = [2,4]
  a2 = [6,3]
  
   |____________(a1)_________________________
 4-|             7_______            T2      |
   |            /        ---______           |
   |           /                  -----______|
 3-|  T3      /                           __-7(a2)
   |        /                          _--   |
   |       /         T            __---      |
 2-|      /                    _--           |
   |     /                __---              |
   |   /              _---                   |
 1-|  /          __---                       |
   | /    ____---                T1          |
   |/__---                                   |
 0-|-------------------------------------------
   |      |      |      |      |      |      | 
   0      1      2      3      4      5      6 
 
  - it is possiable to calc the area of each
    triange (T, T1, T2, T3)
   T1 = 1/2*a[1,1]*a[2,1]
   T2 = 1/2*(a[1,1] - a[1,2])*(a[2,2]-a[2,1])
   T3 = 1/2*a[1,2]*a[2,2]
   
   T = a[1,1] *a[2,2] - T1 - T2 - T3
  
  - determinant is given a 2*T
----

----
Linear System (2X2)
 - defining two linear eq's in 
   matrix format
 - Linear Map is formally defined as
    v' = A*v 
   - in that it preserves linear combinations of
     vectors.   
	
  2*u1 + 4*u2 = 4
    u1 + 6*u2 = 4
	-as-
  [ 2 4   [u1    [4
    1,6 ]* u2] =  4]
 
  - the possiable solutions is named
    solution space
  - roughly divided into 
   (1) exactly on solution vector (u)
       when det(A) != 0
   (2) there is no solution whatsoever
   (3) there are an infinite many solutions
----

----
Cramer's rule
 - based on the geometry of the parallelograms
   formed by a linear system
   a <- matrix(c(2,1,4,6),ncol=2)
   b <- matrix(c(4,4), ncol=1)
   
   u1Numer <- matrix(c(b[1,1],b[2,1],a[1,2],a[2,2]), ncol=2)
   u2Numer <- matrix(c(a[1,1],a[2,1],b[1,1],b[2,1]), ncol=2)
   uDemon <- matrix(c(a[1,1],a[2,1],a[1,2],a[2,2]), ncol=2)
   
   u1 <- det(u1Numer) / det(uDemon)
   u2 <- det(u2Numer) / det(uDemon)
----

----
Gauss Elimination
 - involves tech terms of 
 - back substitution: where we solve for 
   u2 then use its solution-value to solve for u1
  u1 = b2/a2,2
  u1 = 1/a1,1 * (b1 - u2*a1,2)
   
 - foward elimination: the process of getting a[2,1] to equal 0
    which is required for back-sub to work.
 - gauss elimination: the process of foward-elim. followed by
   back sub.
  - based on rule that linear maps do not change linear combos.
    which means applying a linear map to all vectors will not 
	change u1, u2.
 
 - get a[2,1] to zero can be done using a Shear, defined as
  - re-write into column form so Algebraically looks like
               [a[1,1]        [a[1,2]             [b[1,1]
   shearA*(u1 * a[2,1]] + u2 * a[2,2]] ) = shearA* b[2,1]]
   
   a <- matrix(c(2,1,4,6),ncol=2)
   
   #break matrix a into two columns
   aCol1 <- matrix(c(a[1,1],a[2,1]), ncol=1)
   aCol2 <- matrix(c(a[1,2],a[2,2]), ncol=1)
   b <- matrix(c(4,4), ncol=1)
   
   #calc shear
   shearA <- matrix(c(1,(-1*a[2,1]/a[1,1]),0,1), ncol=2)
   
   #take shear time each column
   newACol1 <- shearA %*% aCol1
   newACol2 <- shearA %*% aCol2
   newB <- shearA %*% b
   
   #put it back together as a linear system, completes foward-elim.
   newA <- matrix(c(newACol1[1,1], newACol1[2,1], newACol2[1,1], newACol2[2,1]), ncol=2)
   
   #back sub.
   u2 = newB[2,1] / newA[2,2]
   u1 = (1/newA[1,1])*(newB[1,1] - u2*newA[1,2])
----

----
Pivoting
 - idea or rearranging the linear solution so a shear may 
   be calc'ed and thereby back sub.
 [0 1    [u1    [1
  1 0] *  u2] =  1]
  - a[1,1] is zero and we can't divide by zero
  - as eq's they would look like
  0*u1 + 1*u2 = 1
  1*u1 + 0*u2 = 1
  - then flip the order of them
  1*u1 + 0*u2 = 1
  0*u1 + 1*u2 = 1
  - and convert back to linear system
 [1 0    [u1    [1
  0 1] *  u2] =  1]
  
 - there is likewise ability to perform 
   column pivoting
 [0 1/2    [u1    [0
  0  0 ] *  u2] =  0]
  -to-
  0*u1 + 1/2*u2 = 0
  0*u1 +  0*u2  = 0
  -flipped as
 1/2*u2 + 0*u1 = 0
  0*u2  + 0*u1 = 0
  -back to linear system
 [1/2 0    [u2    [0
   0  0] *  u1] =  0]
----
   
----
Inverse ops & Maps
 - applying an inverse is a form of undo'ing 
   a linear map
 A*u = b
  -then-
 u = A^-1*b
 
 - given two vectors which are known to map
   to two other vectors, solve for the Matrix
 
 A*v1 = v'1
 A*v2 = v'2
 A*(v1, v2) = v'1,v'2
  -shortened as-
 A*V = V'
 A = V'*V^-1
 - insuch a case the application of matrix
   A is known as "change of basis"
   
 -example
  v1 <- c(1,1)
  v2 <- c(-1,1)
  
  vTick1 <- c(-1,-1)
  vTick2 <- c(1, -1)
  
  V <- matrix(c(v1[1],v1[2],v2[1],v2[2]),ncol=2)
  V2neg1 <- solve(V)
  
  VTick <- matrix(c(vTick1[1],vTick1[2],vTick2[1],vTick2[2]),ncol=2)
  A <- VTick %*% V2neg1
---- 

----
Affine maps 
 - linear map was to map vector to vector
 - affine is to map points to points
  - affine maps are to move and orient
    objects like in visual graphics
  - are composed of components named
   - translation (p): an object is moved
      w/o changing its orientation
   - linear map (A)
  - while linear maps are releated to ratios
    affine maps leave ratios unchanged
   
  x' = p + x1*a1 + x2*a2
  x' = p + A*x
  
  - the x' has the same coordinates 
    in the new system that x did in the 
	former

  - technically the linear map A is 
    applied to the vector x - o
	where o is the (0,0) of the 
	former coordinate system
  x' = p + A*(x - o)
  
 - Translation, as a affine map is written 
   as  x' = p + I*x
----

----
General Affine maps
 - Rotate: have point r and want to rotate
   some pt (x) by (a) degrees
  x' = A*(x - r) + r
  
  -example
  A <- getRotationMatrix(90)
  r <- c(2,1)
  x <- c(3,0)
  
  A %*% (x - r) + r # (3,2)
 
 - Reflect: have line (l) and point (x)
   and want to reflect (x) across line (l)
  - uses the "Foot of a given point" where its
    value (here called (p)) is the mid-pt 
	of the reflection
  p = 1/2*x + 1/2*x'
  x'= 2p - x
----
   