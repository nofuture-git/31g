Microsoft® .NET Remoting
By: Scott McLean; James Naftel; Kim Williams
Publisher: Microsoft Press
Pub. Date: September 25, 2002
Print ISBN-13: 978-0-7356-1778-0
Print ISBN-10: 0-7356-1778-3

----
Misc
 - advanced debugging in Visual Studio
 - Ctrl+Alt+I to open the Immediate window
 - .load sos.dll to load 'son of strike' 
   - the project must be set to debug unmanaged code 
   - and it must target x86 processor 
   - http://msdn.microsoft.com/en-us/library/bb190764.aspx
   - http://support.microsoft.com/kb/311503
 - The information within the MethodTable is available through 
   Type.RuntimeTypeHandler
    - TypeHandle, obtained from the ObjectInstance is an offset 
	  from the MethodTable
 - FastCall is a .NET calling convention which prefers passing args 
   for functions into registers and the others placed on the stack 
   right to left.
 - 85000 bytes is the point at which an object goes onto the large object heap
   - the large object heap is not compacted
   - full GC collection is the only time the LO heap gets included
   - the GC heap is compacted after each collection
 - value-types are inlined on the thread call stack or on the GC Heap
 - reference-types are on the GC heap or LO heap
----

----
Basics
 - CLR Bootstrap loads three app domains, all contained in the Managed Process
  - Default AppDomain
  - Shared AppDomain
  - System AppDomain
 - System Domain creates both the Shared Domain and default
   - will load mscorelib.dll into the Shared domain
   - contains a map of all global string literals
   - generates process-wide interface IDs
 - Shared Domain will contain the System namespace 
   - manages an assembly map indexed off a base address
 - Default Domain contains non-shared user code
   - multiple app domains will be present for code that is heavy on 
     runtime resolution or uses plug-in style dependencies
 - Each app domain has its SecurityContext and DefaultContext
   - along with its own SecurityDescriptor, 
   - loader heaps, 
   - handle tables
   - Interface VTable Map Manager
   - and Assembly Cache
 - Loader heaps hold types together while GC heap contains instances
   - a loader heap will grow by specific size
   - 'hold types together' meaning 
     - MethodTables
	 - MethodDescs
	 - FieldDescs
	 - Interface Maps
   - two loader heaps exist following the 80/20 rule 
     - High Frequency Heap is the 80
	 - Low Frequency Heap is the 20
   - a Stub Heap handles P/Invoke and COM Wrappers
 - One process may contain multiple Application Domains
 - One application may contain multiple Context
 - One AppDomain always has at least one Context named 'default context'
 - There is a .NET Remoting boundary between appdomains and between context 
   therein
 - Any given object is either remotable or nonremotable
 - Type is remotable only if
  - The type is defined as capable of crossing .NET Remoting boundary
  - AND Other objects may access an instance thereof across boundary
  - both must be true.
----

----
Remotable Types
(1) Marshal-by-Value
 - is a serializable type 
 - is decorated with [Serializable] attribute
 - implements the ISerializabe interface
(2) Marshal-by-Reference 
 - for access to the same instance in an AppDomain
 - what is given is a reference thereof, not a copy thereof
 - extends the MarshalByRefObject
(3) Context-Bound
 - interAppDomain remoting
 - objects extending System.ContextBoundObject are restricted to a context
 - in such case .NET Remoting is required to access the context bound instance
 - this implies that all objects are NOT context bound by default since one 
   must define them as such 
----

----
Remote Object Activation
 - instance in the source must first be actived
 - activation takes place in the source not the target
 - performed at System.Runtime.Remoting.RemotingConfiguration
  - ApplicationID is a GUID
  - ApplicationName is a string and is used in the URI for the remote object
  - Configure can accept a configuration file
  - ProcessId is another guid for which process this is partaking.
  - RegisterActivted[...] Client & Service Type
  - RegisterWellKnown[...] Client & Service Type
   - these four inturn have Get[...] counterparts
 
 Two types of activation
 (1)Server Activation
 - activation is defined per machine not by the type itself
 - server activation first 'publishes' its active types as a URI
 - Sub-divided as two types of Server Activation
  1.1 Singlton Activation
   - only one instance of the type is active at any given time
   - one instance to handle all request
   - maintains state between client request
   - the source appDomain (aka server) must call 
   System.Runtime.RemotingConfiguration.RegisterWellKnownServiceType(
					type(MyNameSpace.MyType),
					"myURI",
					System.Runtime.Remoting.WellKnownObjectMode.Singleton);
      to make the type 'published'.
   - the client AppDomain must, inturn, call
   RemotingConfiguration.RegisterWellKnownClientType(
                    typeof( MyNameSpace.MyType ),
                    "http://SomeWellKnownURL/myURI" );
	 to access the remote singleton.

  1.2 SingleCall Activation
   - each subsequent call produces a new instance on the server
   - suited for stateless programming
   - upon the client consuming the method call therein the instance is gc'ed
   - the server calls
   RemotingConfiguration.RegisterWellKnownServiceType( 
                                  typeof( MyType ),
                                  "myURI",
                                  WellKnownObjectMode.SingleCall );
   - the client, inturn, calls the similar
   RemotingConfiguration.RegisterWellKnownServiceType( 
                                  typeof( MyType ),
                                  "http://myHost/myURI",
                                  WellKnownObjectMode.SingleCall );

 (2)Client Activation
  - intended to allow each client to have a unique instance of a remote type
  - the server first calls
  RemotingConfiguration.RegisterActivatedServiceType(typeof(MyType));
  - then a client calls
  RemotingConfiguration.RegisterActivatedClientType(typeof(MyType), 
							"http://SomeURL");
----

----
Remote Object Lifespan
 - performed via manager instead of count/ping
 - where count/ping is a count of current clients
   and ping is the verifier client is active
 - an AppDomain contains a LeaseManager who tracks Lease object
   having a remotable type associated with the Lease object
   and, furthermore, each Lease object is registered to a Sponser
   object that may renew the lease with the Manager.
   
 - Lease objects encap' a TimeSpan object
 - the interface is defined in the ILease type
 - upon activation, of all forms, the runtime calls the MarshalByRefObject's
   InitializeLifetimeService() member
 - InitializeLifetimeService() returning null means the lease never expires
 - ILease functions according to 
  - InitialLeaseTime defines a TimeSpan for which the lease is initially valid
  - at initialization time the CurrentLeaseTime equals the InitialLeaseTime
  - RenewOnCallTime is a value who defines what the lease is renewed to
   - upon each call to the remoting object this property is called 
     by the framework
  - SponsorshipTimeout is a value for which Remoting will wait after 
    having notified the caller the remote obj has expired.
	
 - LeaseManager is AppDomain specific having a Hashtable of that maps
   members to a DateTime upon which expiration occurs.
   - the manager loops its hashtable every 10 seconds by default
   - it is configurable by calling
   LifetimeServices.LeaseManagerPollTime = System.TimeSpan.FromMinutes(5);
   
   - LeaseManager will notify its registered Lease objects of expiration
   - Lease objects call thier sponser to have thier lease renewed
    - every Sponser registered to a Lease must renew it (all or nothing)
  - upon a Lease being expired
   - sets itself to System.Runtime.Remoting.Lifetime.LeaseState.Expired 
   - notifies LeaseManager to remove it from the lease table
   - disconnects the associated remote object from the Remoting framework
   - disconnect the Lease from the Remoting framework.

 - a Lease's Sponser is defined by the ISponser interface
 - a type implementing this interface must still, itself, 
   extend the MarshalByRefObject
   since it recieves callback from the remote appdomain 
 - a Sponser is registered to a Lease using the ILease.Register member
 - the framework defines a concrete class for performing this 
 System.Runtime.Remoting.Lifetime.ClientSponsor 
   which extents MarshalByRefObject and implements ISponser
   - by calling this concrete class's Register and passing it a 
     MarshalByRefObject instance it will register itself as a sponsor 
	 on for the associated Lease on the remote AppDomain
   - will also register the lease with the remote AppDomain's LeaseManager
----

----
Activity of Remoting
 - remoting itself is crossing an appdomain or context boundary
 - clients must use a proxy to actually communicate to MarshalByRefObject 
 - the activity is facilitated by the ObjRef type defined at
 System.Runtime.Remoting.ObjRef 
 - the remoting infrastructure instantiates a ObjRef 
  - this instance will fully describe the underlying MarshalByRefObject type
  - then serialize it to a bit stream
  - send the bit stream to the target .NET Remoting subdivision
  - target then deserializes the bit stream
  - Unmarshals the ObjRef into a proxy to be used to 
    communicate across the boundary
  - a URI is required to facilitate 
   - for server activated type the uri is published 
   - for client activation the .NET Remoting generates a Guid to be the URI
  - the information that is serialized is specific to the type but not
    its concerte implementation.
  - therefore the target appdomain must have access to the same assemblies
    for which this type is dependent 
  - the ObjRef will also provide the 'channel' within which
   - the source MarshalByRefObject's context, appDomain and process
   - the interprocess-communication detials (port, address, etc)
 
 - Remoting is carried through by a proxy
 - there are two defined proxies used
 (1) the Transparent Proxy
    - this is generated by the framework at runtime
	- has an interface that is identical to the remote object's
	- transparent proxy is an internal type defined at
	System.Runtime.Remoting.Proxies.__TransparentProxy 
	- transparent proxy simply delivers message to the Real Proxy
 (2) the Real Proxy
   - creates the actual instance of IMessage type
   - sends the message to the .NET Remoting framework
   - is defined as abstract type at 
   System.Runtime.Remoting.Proxies.RealProxy 
   - all actual proxy extend this abstract type
   - the concrete type used by the framework is defined at
   System.Runtime.Remoting.Proxies.RemotingProxy
   - a custom implementation of RealProxy may be used
   
 - message transmitted across boundaries are similar in 
   nature to the way members are called via the call-stack
 - actual message objects are defined at
 System.Run­time.Remoting.Messages.IMessage 
 
 - channels are typical IPC 
 - two frameword defined channels are TCP and HTTP
 - TCP channel is defined at 
 System.Runtime.Remoting.Channels.Tcp 
   and it implements IChannel, IChannelReceiver, 
   and IChannelSender for duplex communication
 - HTTP channel is defined at
 System.Runtime.Remoting.Channels.Http 
   and is also duplex likewise
 - configured at 
 System.Runtime.Remoting.Channels.ChannelServices
 - implementing this appears as 
 //make a channel object
 HttpChannel myChannel = new HttpChannel(8080); //8080 being the port number
 ChannelServices.RegisterChannel(myChannel);
 
 - Channel Sink is a type of Pipe design
 - first channel sink in pipe serializes the IMessage
   into a bit stream appropriate for the Channel type 
   (i.e. TCP, HTTP)
 - other channel sinks follow
 - the last channel sink is responsiable for transport.
 - on the other side the process is repeat backwards
 - having the transport channel sink first, ending with the 
   formatter sink and then off to a real proxy which invokes
   the target object member.
----

----
Steps Required to add .NET Remoting Server-Side
(1) Making a type remotable
 - involves decorating the type that is passed through boundaries with 
   [Serializable] attribute.
 - having the server side type accessable by extending MarshalByRefObject
(2) Choosing a host application domain
 - remoting host must be active prior to the first client call
 - involves the choice upon which the server side type is exposed
 - choices include
  - Console app. (must be started first)
  - Windows Form (must be started first)
  - Windows Service (always running)
  - IIS (always running)
  - COM+ (always running)
(3) Choosing an activation model
 - upon client activation the client controls the lifetime
 - upon server SingleCall activation each response is a new instance
 - upon server Singlton activation the object presist on the server
(4) Choosing a channel and a port
 - using HTTP the messages will be readable as plain text
 - decision involves
  - if the channel must pass through a firewall
  - if plain-text data is a security problem
  - if security features of IIS are required
(5) Choosing how clients will obtain the server's metadata
 - the client will need access to the assemblies that contain all the 
   types being exposed by the Remoting framework
(6) Configuring the server for .NET Remoting
 - first way is programmatically appearing as this
 //1. register the server-side listener
 System.Runtime.Remoting.Channels.Http.HttpChannel myChannel = 
          new HttpChannel(8080); //8080 is the port number
 System.Runtime.Remoting.Channels.ChannelServices.RegisterChannel(myChannel);
 
 //2. publish the listener 
 System.Runtime.Remoting.RemotingConfiguration.RegisterWellKnownServiceType(
    type(MyImplOfMBRO),
    "anyString",
    System.Runtime.Remoting.WellKnownObjectMode.Singleton);
    
 - this may also be performed completely from a app.config files as such
 
 //this appears in the code
 System.Runtime.Remoting.RemotingConfiguration.Configure(@..\myAppConfig.config)
 
 <!--this appears in the config file -->
 <configuration>
    <system.runtime.remoting>
        <application name="MyAppName">
            <service>
                <wellknown mode="Singleton" 
                    type="MyNamespace.MyImplOfMBRO, MyImplOfMBRO" 
                    objectUri="anyString" />
            </service>
            <channels>
                <channel ref="http"
                    port="8080" />
            </channels>
        </application>
    </system.runtime.remoting>
 </configuration>
----

----
Steps Required to add .NET Remoting Client-Side
(1) Have a client type being compiled into a serperate binary
(2) The seperate binary needs a reference to all the types defined on the server
(3) The code of the client having an instance var of the MyImplOfMBRO type
 - best practice is to contain functionality in an interface then implement 
   the interface and have the implementation extend MarshalByRefObject
 - therein the client side will work with an instance var of the interface type
   and not the actual MarshalByRefObject extension
(4) Configure the client to communicate with the server
 //1. register a client-side channel
 HttpChannel myCChannel = new HttpChannel(0)//have the client use any port
 //this action will register the IChannel instance with the client's
 //.NET remoting infrastructure and the channel itself will transport the 
 //message across the boundaries
 ChannelServices.RegisterChannel(myCChannel);
 
 //2. register the published type on the server
 //this action is setting it so that MyImplOfMBRO is a remote type that resides
 //in another app domain
 WellKnownClientTypeEntry remoteType = new WellKnownClientTypeEntry(
        typeof(MyImplOfMBRO),
        "http://localhost:8080/anyString");
        
 RemotingConfiguration.RegisterWellKnownClientType(remoteType);
 
 //now the type may be returned like its defined locally
 return new MyImplOfMBRO();
 
 - like the server-side counterpart, this functionality may be defined in a 
   config file instead
   
 //this appears in the code
 RemotingConfiguration.Configure(@"..\myClientConfig.config");
 return new MyImplOfMBRO();
 
 <!--this appears in the config file -->
 <configuration>
   <system.runtime.remoting>
      <application name="MyAppName">
         <client>
            <wellknown 
               type="MyNamespace.MyImplOfMBRO, MyImplOfMBRO" 
               url="http://localhost:8080/anyString" />
         </client>
         <channels>
            <channel ref="http" port="0" />
         </channels>
      </application>
   </system.runtime.remoting>
 </configuration>
----   

----
Summary Facts
 - classes that wish to be transported as instance variables of the extendor of 
   MarshalByRefObject must be decorated with [serializable] attribute.
 - To cross domain boundaries a class must extend MarshalByRefObject.
 - For the client-side to use the remote type it will need a reference to the
   assembly that defines the type, same as the server.
 - When Server activation happens and the type is Singleton - the client will
   call 'new' but what is actual returned is more like static since its the 
   existing instance.   
----

----
Custom Sink and Channels 
 - will be required when a custom serialization surrogates are being used
   to serialized types across the app boundary
   
using System;
using System.IO;
using System.Runtime;
using System.Runtime.Remoting;
using System.Runtime.Remoting.Channels;
using System.Runtime.Remoting.Messaging;
using System.Runtime.Serialization;
using System.Runtime.Serialization.Formatters;
using System.Runtime.Serialization.Formatters.Binary;
using System.Collections;

namespace Remoting
{
	public class MyClientFormatterSink : IClientFormatterSink
	{

		private IClientChannelSink _nextChannelSink;
		private IMessageSink _nextMessageSink;

		public MyClientFormatterSink(IClientChannelSink next)
		{
			_nextChannelSink = next;
		}

		#region IMessageSink Members

		public IMessage SyncProcessMessage(IMessage msg)
		{
			//
			// Serialize message to a stream.
			TransportHeaders    requestHeaders = new TransportHeaders();

			Stream requestStream = 
        _nextChannelSink.GetRequestStream(msg,requestHeaders);
        
			if ( requestStream == null ){requestStream = new MemoryStream();}

      //special surrogate selector for MarshalByRefObject types
			RemotingSurrogateSelector rem_ss = new RemotingSurrogateSelector();

			BinaryFormatter fm = new BinaryFormatter();
			fm.AssemblyFormat = FormatterAssemblyStyle.Simple;
			fm.FilterLevel = TypeFilterLevel.Full;
			fm.SurrogateSelector = rem_ss;
			fm.Context = new StreamingContext(StreamingContextStates.Other);

			// Serialize a MethodCall message to the stream.
			MethodCall mc = new MethodCall(msg);
			fm.Serialize(requestStream, mc);

			// Let sink chain process the message.
			ITransportHeaders   responseHeaders = null;
			System.IO.Stream    responseStream = new System.IO.MemoryStream();

			this._nextChannelSink.ProcessMessage( mc,requestHeaders,
                                            requestStream,
                                            out responseHeaders,
                                            out responseStream );

			IMessage mr = (IMessage)fm.Deserialize(responseStream);
			return mr;

		}

		public IMessageSink NextSink
		{
			get
			{
				return _nextMessageSink;
			}
		}

		public IMessageCtrl AsyncProcessMessage(IMessage msg, 
                                            IMessageSink 
                                            replySink)
		{
			throw new NotImplementedException();
		}

		#endregion

		#region IClientChannelSink Members

		public void AsyncProcessRequest(IClientChannelSinkStack sinkStack, 
                                    IMessage msg, 
                                    ITransportHeaders headers, 
                                    Stream stream)
		{
			throw new NotImplementedException();
		}

		public void ProcessMessage(IMessage msg, 
                              ITransportHeaders requestHeaders, 
                              Stream requestStream, 
                              out ITransportHeaders responseHeaders, 
                              out Stream responseStream)
		{
			throw new NotSupportedException();
		}

		public void AsyncProcessResponse(IClientResponseChannelSinkStack sinkStack, 
                                    object state, 
                                    ITransportHeaders headers, 
                                    Stream stream)
		{
			throw new NotImplementedException();
		}

		public System.IO.Stream GetRequestStream(IMessage msg, 
                                             ITransportHeaders headers)
		{
			throw new NotSupportedException();
		}

		public IClientChannelSink NextChannelSink{get{return _nextChannelSink;}}

		#endregion

		#region IChannelSinkBase Members

		public IDictionary Properties{get{return null;}}

		#endregion
	}
	public class MyClientFormatterSinkProvider : IClientFormatterSinkProvider
	{
		public MyClientFormatterSinkProvider(){}

		public MyClientFormatterSinkProvider( IDictionary properties,
                                                   ICollection providerData)
		{
		}

		// Build the client-side channel sink chain:
		public IClientChannelSink CreateSink (IChannelSender channel,
                                          string url,
                                          object remoteChannelData)
		{
			// Ask the next provider for the sink chain.
			IClientChannelSink chain = _Next.CreateSink(channel,
                                                  url,
                                                  remoteChannelData);

			// Add our formatter to the beginning of the chain.
			IClientChannelSink sinkFormatter = 
          new MyClientFormatterSink(chain);

			return sinkFormatter;
		}

		private IClientChannelSinkProvider _Next=null;
		public IClientChannelSinkProvider Next{get{return _Next;}
                                           set{_Next = value;}}
	}

	public class MyServerFormatterSink : IServerChannelSink
	{
		private IServerChannelSink  _NextChannelSink;

		public MyServerFormatterSink( IServerChannelSink snk)
		{
			_NextChannelSink = snk;
		}

		public IDictionary Properties { get { return null; } }

		public IServerChannelSink NextChannelSink{get{return _NextChannelSink;}}

		public Stream GetResponseStream(IServerResponseChannelSinkStack sinkStack,
                                    object state,
                                    IMessage msg,
                                    ITransportHeaders headers)
		{
			// We dont expect this method to be called because
			// we dont push ourselves onto the response sink stack.
			throw new NotSupportedException();
		}

		public void AsyncProcessResponse(IServerResponseChannelSinkStack sinkStack,
                                     object state,
                                     IMessage msg,
                                     ITransportHeaders headers,
                                     Stream stream)
		{
			// Could implement, but have not.
			throw new NotImplementedException();
		}

		public ServerProcessing ProcessMessage(IServerChannelSinkStack sinkStack,
                                          IMessage requestMsg,
                                          ITransportHeaders requestHeaders,
                                          Stream requestStream,
												                  out IMessage responseMsg,
                                          out ITransportHeaders responseHeaders,
                                          out Stream responseStream)
		{
			// Initialize output parameters.
			responseMsg     = null;
			responseHeaders = null;
			responseStream  = null;

			// Set up to deserialize request stream.
			RemotingSurrogateSelector rem_ss = new RemotingSurrogateSelector();
			SurrogateSelector ss = new SurrogateSelector();
			//ss.AddSurrogate(typeof(System.Web.HttpApplication),
      //                new StreamingContext(StreamingContextStates.All),
      //                new Remoting.HttpApplicationSurrogate());
			//rem_ss.ChainSelector(ss);

			
			BinaryFormatter fm = new BinaryFormatter();
			fm.AssemblyFormat = FormatterAssemblyStyle.Simple;
			fm.FilterLevel = TypeFilterLevel.Full;

			fm.SurrogateSelector = null;
			fm.Context = new StreamingContext( StreamingContextStates.Other );

			IMessage mymsg = (IMessage)fm.Deserialize(requestStream);
			//this appears to be required everytime
			mymsg.Properties["__Uri"] = "REMOTE_URI";
       
			// When calling the dispatch sink (the next sink in our chain), 
      //the request stream must be null.
			ServerProcessing sp = this._NextChannelSink.ProcessMessage( sinkStack,
                                                          mymsg,
                                                          requestHeaders,
                                                          null, 
                                                          out responseMsg,
                                                          out responseHeaders,
                                                          out responseStream );

			if ( sp == ServerProcessing.Complete )
			{
				// Serialize response message to the response stream.
				if ( responseMsg != null && responseStream == null )
				{
					responseStream = 
            sinkStack.GetResponseStream(responseMsg,responseHeaders);

					if ( responseStream == null ){responseStream = new MemoryStream();}

					fm.SurrogateSelector = rem_ss;
					fm.Serialize(responseStream, responseMsg);
				}
			}
        
			return sp;
		}
	}

	public class MyServerFormatterSinkProvider : IServerFormatterSinkProvider
	{
		public MyServerFormatterSinkProvider()
		{
		}

		// This ctor form provides properties from configuration file.
		public MyServerFormatterSinkProvider( IDictionary properties,
			                                             ICollection providerData )
		{
		}

		private IServerChannelSinkProvider _Next;

		public IServerChannelSink CreateSink(IChannelReceiver channel)
		{
			IServerChannelSink chain = _Next.CreateSink(channel);
			IServerChannelSink sinkFormatter = new MyServerFormatterSink(chain);
			return sinkFormatter;
		}

		public void GetChannelData(IChannelDataStore channelData)
		{
			if ( _Next != null )
			{
				_Next.GetChannelData(channelData);
			}
		}

		public IServerChannelSinkProvider Next
		{
			get
			{ return _Next; }
			set
			{ _Next = value; }
		}
	}
}
----