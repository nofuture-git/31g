Notes Terraform
----

----
Terraform: Up & Running, 2nd Edition
by Yevgeniy Brikman
Publisher: O'Reilly Media, Inc.
Release Date: September 2019
ISBN: 9781492046905
----

----
Terraform basics
 - is a single executable binary
 - is written in Go
 - performs API calls to a known cloud provider (AWS, Azure, 
   Google Cloud, DigitalOcean, OpenStack and more)
 - is a single .exe in Windows without any installer 
  - needs to be added to the PATH variable
 - uses environment variables for AWS IAM users
 [System.Environment]::SetEnvironmentVariable("AWS_ACCESS_KEY_ID", `
                                              "ABCDEFGHIJKLMNOPQRS", `
                                              [System.EnvironmentVariableTarget]::Process)
                                              
 [System.Environment]::SetEnvironmentVariable("AWS_SECRET_ACCESS_KEY", `
                                              "c3VwZXJfL1NlY3JldF9uZWVkc1RvQmUxMTExMTExMTE=", `
                                              [System.EnvironmentVariableTarget]::Process)
                                              
 - Terraform code is a syntax named HashiCorp Configuration Language (HCL)
 - is expected file extension of .tf
 - documentation at https://registry.terraform.io/providers/hashicorp/aws/latest/docs
 - terraform.exe will look for a file named 'main.tf" in the working directory
 - typical ignore files of Terraform are: .terraform *.tfstate *.tfstate.backup
----

----
Infrastructure as Code (IAC)
 - idea of how code is hosted, managed, deployed and monitored 
   is all considered a software problem is is handled as code
   itself
 - benefits include:
  - self-service: by the developers without assistance from a sysadmin
  - speed: steps as code will run faster than any human user
  - safety: steps as code are not prone to typos and manual errors
  - documentation: the infrastructure is clearly defined in as code
    and not hindered by tribal knowledge
  - version control: infrastructure changes are under source control
    with logs, commit comments, user names, etc.
  - validation: IAC can be code reviewed
----
 
----
Ad hoc scripts
 - IAC as bash, python, powershell scripts 
  - tends to lack a standard API for standard IAC tasks
  - quickly becomes overwhelming 
----

----
Configuration Management Tools 
 - IAC as applications to install and manage software on existing servers
 - examples include: Chef, Puppet, Ansible and SaltStack
 - is convention based for common IAC tasks like file 
   layout, secrets mgmt, etc 
 - idempotence: code that runs correctly no matter how many 
   times its run\re-run
 - intended for distributed networks of remote machines
----

----
Server Templating Tools
 - IAC as fully self-container snap-shots of a whole machine from OS up
 - examples include: Docker, Packer and Vagrant
 - developed the idea of immutable infrastructure 
  - don't change images, just make a whole new one
 - virtual machines and containers
  - a VM is virtualizing the very hardware 
  - container is virtualizing just the user space
   - user space being the part of virtual memory used by applications
   - in contrast to kernel space being the part of the virtual memory
     used by the kernel
----

----
Orchestration Tools
 - IAC as a configuration management tool of all the template servers
 - examples include: Kubernetes, Marathon/Mesos, Amazon Elastic Container 
   Service (Amazon ECS), Docker Swarm and Nomad
 - handle the updates to existing templates in a rolling fashion
  - blue-green deployment
  - canary deployment
 - auto-healing: idea of an orchestration tool replacing poor performing 
   running templates with new ones
 - auto-scaling: idea of an orchestration tool adding\removing running 
   templates based on demand-load
 - load-balancing: idea of orchestration tool distributing demand-load 
   efficiently across the running templates
 - service discovery: idea of orchestration tool allowing for running 
   templates to find and communicate with other running templates
----

----
Provisioning Tools
 - IAC as creation the infrastructure itself
 - examples include: Terraform, CloudFormation and OpenStack Heat
 - creates the servers, databases, caches, load balancers, queues, 
   monitoring, subnet cfg, firewall settings, routing rules, 
   digital certs, etc.
----

----
Terraform Resource Syntax
 - a first-class, kind-of, type is a 'resource'
 - looks similar to a CSS Rule
 resource "<PROVIDER>_<TYPE>" "<NAME>" {
  [CONFIG ...]
 }
 
 - syntax example:
 resource "aws_instance" "myExample" {
  ami = "ami-0c55b159cbfafe1f0"
  instance_type = "t2.micro"
 }
 
 - 'resource' is a keyword
 - "aws_instance" is a naming convention of provider_type
 - "myExample" is the name is something I assign
 - what is within the body is specific config key-value pairs
   for that provider_type
----

----
Terraform Resource Attribute Reference
 - a string interpolation schema
 - a reference to some value defined elsewhere
 - uses a snake-plus-dot notation
  - <PROVIDER_<TYPE> are same as always
  - <NAME> is the name of the resource 
  - <ATTRIBUTE> is some key-value in the body of 
    the resource
 <PROVIDER>_<TYPE>.<NAME>.<ATTRIBUTE>
 
 - assignment of some value to a reference 
   is accomplished by enclosing it in square-braces
  vpc_security_group_ids = [aws_security_group.instance.id]  
  
  - this would mean some other resource is defined 
    for the 'aws_security_group' 
  - the name of this resource is 'instance'
  - lastly, this resource has config attribute named 'id'
----   

----
Terraform Input Variables
 - allow for programmatic declaration of variable 
   in a .tf file
 - uses the 'variable' keyword
 
 variable "my-port-number" {
  description = "Basic example of a programmatic terraform variable"
  type = number
  value = 8080
 }
 


----
Running terraform
 - working directory contains a main.tf file
 - one-time run to download dependencies on given provider 
  - as defined in the main.tf 'provider'
  - will also create various other files and folder in working dir
 terraform init
 
 - next is the command 'plan'
  - like a 'WhatIf' parameter in PowerShell
  - determines what terraform _will_ do
  - console output has three ascii chars to indicate
    expected future state
   - '+' means something will be created
   - '-' means something will be removed
   - '~' means something will be modified
   - '-/+' means something will be replaced
 terraform plan
 
 - 'apply' command will push what was planned to the 
   cloud provider
  - within the cloud providers console verify it worked
 terraform apply
---- 
 
 