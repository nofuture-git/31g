Notes Python
----
Think Python, 2nd Edition
By: Allen B. Downey
Publisher: O'Reilly Media, Inc.
Pub. Date: December 9, 2015
Print ISBN-13: 978-1-4919-3936-9
Pages in Print Edition: 300
code examples: http://www.greenteapress.com/thinkpython2/code

Docx at 
https://docs.python.org/3.5/reference/index.html

----

----
Command line 
 python [-i | -q | -V | -h ] [ scriptFile | -c command | -m module | - ] [args*]
 -i will execute the script then inter interactive mode
 -q will not print header
 -v will print the version
 -h will print help
 
 - having just the "-" will read command from the standard input stream 
 - args* will be passed to script file in global sys.argv[1:]
 
 - interactive mode
  - has the '>>>' as the command input
  - to clear the console 
  
   >>> import os
   >>> os.system('cls') #for windows; 'clear' for linux\os x 
   >>> os.system('notepad.exe') #have the underlying shell exec
   >>> os.startfile('C:\MyFile\SomeHtml.htm') #will open file using it assoc. program
   >>> os.getenv("JAVA_HOME", default=None) #resolve the enviro var.
   >>> os.getcwd() # like 'pwd' on the shell
   >>> os.chdir('C:\\Projects')  #change dir
   >>> os.listdir('C:\\Projects') # like 'ls' on the shell
   >>> os.mkdir('C:\\Projects\MyPy')

 - import sys module 
   >>> import sys
   >>> sys.modules  #gets a dictionary of modules currently in scope
   >>> sys.path     #get list of where modules will be searched for at
   
   
 - the result of the last evaluation may be accessed using a single underscore
 >>> 4 + 2
 6
 >>> _
 6

 - python is interpretated and the source code is typically part of the 
   install (%pyInstall%\Lib\*.py) 
----

----
Globals

 PYTHONPATH default search paths(s) for importing modules, is semi-colon separated
 PYTHONSTARTUP a script that is executed each time the python runtime is started 
 PYTHONHOME alt prefix directory for lib modules
 PYTHONCASEOK for Windows where file name case is ignored for import statements
----

----
Ops,
 - arithmetic ops
  + - * / % 
  - exponent is the 
  **
  - integer div (no remainder)
  //
  - order of op is std 
   PEMDAS
  - each arithmatic op has a compound assignment op as well
   
 - bitwise ops   
 << >> & | ~ ^

 - concat
  + for string concat
  * works to repeat a string
   - "MyString "*3
    MyString MyString MyString 
	
 - line comment char is bash style pound 0x23
  # here is line comment
  
 - block comments may be a here-string
 """
  I write some docx on the api here 
   and what not
 """
  
 - the at symbol is used for decorators (aka. Attributes in .NET)
  @
  
 - ternary
  X if Y else Z
  
 - logical
  or #is short-circuit
  and
  not 
  ==
  != 
  <
  >
  <=
  >=

 - bitwise
  | ^ & << >> ` 

 - sequence assignment
  
 >>> a, b, c, d = [1,2,3,4]
 >>> a, d
 (1,4)
 >>> for (a, b, c) in [[1,2,3],[4,5,6]]
 ...    print(a,b,c)
 ...
 1 2 3
 4 5 6
 
 - have a '*' before sequence variable is for when lengths don't match
 >>> for (a, *b) in [[1,2,3],[4,5,6]]: print(a,b) #this will work
 ...
 1 [2, 3]
 4 [5, 6]
 >>> 

----

----
Literals
 - null is singleton
   None

 - bool
  - actually extends from int
   True  #is an int equal to 1
   False #is an int equal to 0
   >>> 1 == True
   True
   >>> True + 3
   4

 - string
   'my string' #seems more common in docx
   "my string"
  - Esc Seq.
    \newline
    \\
    \n, \r, \t  #std meaning
    \xhh #hex 
   
 - int
   0o177 #for oct
   0x4FD #for hex
   0b1101 #for binary
 - float
   1.23, 3.14e-10, 1. 

 - std lib also include
  - decimal #fixed precision 
  - fraction #keeps numerator and denominator separate
   >>> from fractions import Fraction
   >>> Fraction(1,2) + Fraction(2,4)
   Fraction(1,1)
   
 - conversion through global func\ctors
  >>> eval('Fraction(1,2) + Fraction(2,4)') #eval's the py code and returns the result
  Fraction(1,1)
  >>> int(42.3)
  42
  >>> float(878)
  878.0
  >>> myFrac = Fraction(1,2)
  >>> repr(myFrac)
  'Fraction(1, 2)'
  >>> str(myFrac)
  '1/2'
  >>> hex(128)
  '0x80'
  >>> oct(16)
  '0o20'
  >>> bin(8)
  '0b1000'
----

----
String Methods
 - S is standin for string instance
 - sub is standin for some sub-string
 
 S.find(sub [, start[, end] ) # -1 if not found
 S.rfind(sub [, start[, end] ) #starts on the right
 S.index(sub [, start[, end] ) #raises error if not found
 S.rindex(sub [, start[, end] )
 S.count(sub [, start[, end] ) #num of times 'sub' is present
 S.startswith(sub) #has same options but why
 S.endswith(sub)
 
 S.split([sep [, maxsplit]) #if sep not given, splits on whitespace
                            # for .NET like ToCharArray(), used global list(S)
 S.join(iterable)  #like .NET string.Join(S,iterable)
 S.replace(old, new)
 S.splitlines([keepends]) #splits string to array on line breaks
 
 S.capitalize() #first char is to upper, rest to lower
 S.expandtabs([num]) #replace \t chars with spaces by num (df is 8)
 S.strip() #like .NET Trim()
 S.lstrip() #left trim
 S.rstrip() #right trim
 S.swapcase() #upper chars to lower, lower chars to upper
 S.upper()
 S.lower()
 S.rjust(width [,fill]) #right-justify padded with fill (df is space)
 S.ljust(width [, fill])
 S.center(width [, fill]) #center-justify
----

----
Lists
 - mutable sequences of object references accessed by offset
 - are 0-indexed
 [] #empty list
 [0,1,2,3]
 myList = ['my string', ['my', 'inner', 'list', 3.1415], 1.23, {}]
 
 - list comprehension
 [x ** 2 for x in range(5)] #results in [0,1,4,9,16]
  - may include a test condition
 [x ** 2 for x in range(5) if x % 2 == 0]  #results in [1,4,16]
  - may include another comprehension
 [x + y for x in range(3) for y in [10,20,30]]
 
 L.append(X) 
 L.extend(I) #like .NET .AddRange(I)
 L.sort(key=None, reverse=False) #inline sorting
 L.reverse()
 L.index(X [,i [,j]]) #i,j optional index limiters, raised error if 
                      # object 'X' is not found
 L.insert(i, X)
 L.count(X) #occurances of object X
 L.remove(X) #raises exception if not found
 L.pop([i]) #having list op like stacks, df is last item 
 L.clear()
 L.copy() #returns a shallow copy of L
----

----
Dictionaries
 - mutable mappings of object references accessed by key
 - like assoc. arrays in PHP
 - a.k.a. hashtables

 {} #empty dictionary
 {'myKey' : 4, 'otherKey' : 5}
 {'myInnerDic' : {42 : 'strange'}, 'anotherKey' : 44}
 -use the ctor
 dict(fname='Joe', lname='Sampson', age=44, titles=('something', 'andsomething'))
 
 - other init methods using ctor
 dict(zip('abc', [1,2,3]))
  - same as
 dict([['a',1], ['b',2],['c',3]])
 
 D.fromKeys(['a','b','c'], '') #creates dictionary from a list with df of ''
 
 D.keys()
 D.values()
 D.items() #returns tuple
 D.clear()
 D.copy() #returns shallow copy
 D.update(D2) #union 
 D.get(K) #get by key
 K in D #test for a key (replaces D.has_key(K) )
 for K in D
----

----
Tuples
 - immutable sequences of object references accessed by offset
 -like list but are immutable
 
 () #empty tuple
 (0,) #one-item tuple
 (0,1,2,3) #four item tuple
 ('mystring', (88, 'crazy')) #two-item tuple w\item two as another tuple
----

----
Sets
 - mutable unordered collection of unique and immutable objects.
 - support relational ops 
 - when invoking using operator overloads both operands must be sets
 - when invoking using methods the method arg may be any iterable
 
 set() #makes an empty set
 E = set('abcd') #four item set of 'a', 'b', 'c' and 'd'
 E = {'a', 'b', 'c', 'd'} #same as above
 E = {ord(c) for c in 'abcd'} #same, using comprehension
 E = frozenset(range(-5,5)) #set has 10 items being -5...4
  
 v in E #is 'v' contained in set 'E'
 E1 - E2 #returns items in E1 not found in E2
 
 E1 | E2 #union
 E1.union(E2)
 
 E1 & E2 #intersection
 E1.intersection(E2)
 
 E1 <= E2 #is every item in E1 also in E2
 E1.issubset(E2)
 
 E1 >= E2 #is every element in E2 also in E1
 E1.issuperset(E2)
 
 E1 < E2 #is E1 a subset of E2 (where E2 has additional items)
 E1 > E2 #is E1 a superset of E2 (where E1 has additional items)
  
 E1 ^ E2 #symmetric difference
 E1.symmetric_difference(E2)
 
 E1 |= E2 #adds E2's items to E1
 E1.update(E2)
 
 E.add(x) #adds single itme
 E.remove(x) #removes or errors
 E.discard(x) #removes when present
 x = E.pop() #removes and returns some item
 E.clear() #clears the set of all items
 
 for x in E1 #for each iteration
 E1.copy() #makes a shallow copy 
  
 >>> E1 = set('abcd')
 >>> E2 = set('abcd')
 >>> E1 >= E2
 True
 >>> E1 <= E2
 True
 >>> E1 > E2 #they are in fact the same (equal)
 False 
 >>> E1 < E2 #again, are equal
 False
 >>> E1.remove('z') #errors out
 Traceback (most re ...
 >>> E1.discard('z') #no error, nothing returned 
----

----
String formatting
 # sprintf sytle
 '%s %.2f' % ('my string', 1/3.0)
 '%(n)s %(m)i' % {'n' : 'my string', 'm' : 4}
 
 #.NET style
 '{0} {1:.2f}'.format('my string', 1/3.0)
----
 
----
File IO
 myFile = open(filename, ('r' | 'rb')
  - 'r' for text 
  - 'rb' for binary
  - 'r+' for read\write
  
 myContent = myFile.read() #with 'rb' myContent is a string 
                           #which would contain non-printables
 myFile.read(n)  #read 1 to n more bytes
 myFile.readline() #read upto next newline
 myFile.readline() #list of strings as content
 
 for ln in myFile #uses line iterator of the file object
 
 myFile = open(filename, ('w' | 'wb'))
 myFile.write(S) #write string 'S' to myFile
 myFile.writelines(I) #write iterable I into w/o adding newline at each end
 myFile.close() #release unmanaged resources
 myFile.tell() #current cursor position
 myFile.seek(offset [, 0 | 1 | 2])
  - 0 is offset from start
  - 1 is offset from current position
  - 2 is offset from end
 myFile.isatty() #bool for if file is connected to a tty-like device
 myFile.flush() #flush file's stdio buffer 
 myFile.fileno() #gets id for this file instance
 
 myFile.closed #true | false
 file.mode # 'r' | 'rb' | 'w' | 'wb' | 'r+'
 file.name #files name
 
 - recommended use try\finally for closing
 try:
     #file used
 finally:
     myFile.close()
	 
 - or, like .NET using statement
 with open('temp.txt', 'r') as myfile:
     #myfile is in scope
----
 
----
Syntax Constructs & Conventions
 - blocks are delimited by having the same number of whitespace before the statement
 - nested block is the expression after the ':' on the same line
 - multiple statements on a single line are allowed when separated by a semi-colon (0x3B)
 - single statements may span multiple lines when ending with backslash (0x5C)
 - list, dictionary, tuple and set initializers (literals) may span multiple lines
 - here-string may span multiple lines
 - names begining and ending with double-underscore have special meaning (e.g. __iamspecial__)
 - top-module level names with a single underscore are scoped only to that module

 - src code is in UTF8
 - .NET properties = Py attributes
 - Py3, indentation must be either tabs or spaces
  - not both
  - spaces preferred
  - one tab equals eight spaces
 - single line should be limited to 72 chars
 - package and module names are short and all lowercase
 - class names should be PascalCase
 - exceptions should be suffixed with 'Error'
 - function names are all lowercase with underscore sep.
  - use '_' prefix for non-public fields and methods
 - function args
  - use 'self' for first arg of instance method
  - use 'cls' for first arg of class method
 - constants are in all uppercase with underscore sep. 
----

----
Call Syntax
 - inline function defined using the 'def' construct
  >>> def myfunc(a, b, c, d): print(a, b, c, d)
  
 - function calls are comma-separated and positional
  - a argname=argvalue is allowed in function invocation
  - var-args are defined with the star or double-star 
   - arg with a star in front is an iterable
   - are with double-star in front is a dictionary
  >>> myfunc(*[1,2], **dict(c=3, d=4))  
  1 2 3 4
----

----
Typical Constructs Syntax

 if test:
     suite
 [elif test
     suite]*
 [else:
     suite]
   
 while test:
     suite
 [else:
     suite]
	 
 for target in iterable:
     suite
 [else:
     suite]

 - other single statment keywords and ops
 pass     #noop
 ...      #also noop for 3.X
 break    #exits inner most loop 
 continue #next loop iteration
 del name[i | i:j:k | .attribute] #for data mgmt, not memory mgmt
 
 - lambda expressions, for single line functions
 >>> L = lambda a, b=2, *c, **d: [a, b, c, d]
 >>> L(1,3,2,4,x=1,y=2)
 [1, 3, (2, 4), {'y': 2, 'x': 1}]

 - arbitrary runtime attributes can be added to function def's
 >>> def myfunc(a, b, c, d): print(a, b, c, d)
 >>> myfunc.anAttribute = 'this is arbitrary'
 >>> myfunc.anAttribute
 'this is arbitrary'
 
 - decorators
  - are added atop of a declaration
  - use the Java style '@' char
  - may be added at runtime using the decorator's ctor passing in the def func's variable
  
  @decorator
  def F():
      ...
   - or using runtime attachement
  F = decorator(F)
   
  - allow for multiple decorators by stacking them as separate lines
  @decor00
  @decor01
  @decor02
  def F():
      ....
   - could also be done at runtime like
  F = decor00( decor01( decor02(F)))
----

----
Access Modifiers
 - appear to be only two
 global, nonlocal
---- 

----
Module Imports
 - use dot as path separated
 - is relative to the install dir
 - the .py extension is ommitted
  dir00.dir01.myMod
  
  import [package.]* module [as name] 
     [, [package.]* module [as name]]
 
 - the 'from ... import' copies all names 
   all names assigned at the top level of 
   the module (except having a single underscore prefix)
 
 from [package.]* module import 
             [(] name [as othername]            
             [, name [as othername]]* [)]
----

----
Try Statement
 - has the standard op
 - py has one extra feature of 'else'
  - the 'else' runs after the try block
    when no exception occurred
 - py allows for simply try\finally as well
 
 try:
     suite
 except [ type | (type1, type2) [as value]]: 
     suite
 [except [type [as value]]:
     suite]*
 [else:
     suite]
 [finally:
     suite]
----

----
With Statement
 - similar to .NET's using(IDisposable)
 - allows for multiple declarations in higher py ver.
  - instead of nesting them within each other
 - the equiv. of IDisposable is implementing the 
   __enter__() and __exit__(type, value, traceback)
 
 with expression [as variable]
         [, expression [as variable]]*:
      suite
----

----
Raise Statement
 - similar to the 'throw' in .NET
 - syntax features are as expected
 
 raise myInstance
 raise myType()
 raise  #throws the last exception caught
----

----
Classes
 - supports multiple inheritance 
 - overcomes the runtime problems of diamond by 
   only using the one to the right.
 - parent types are listed in class decl's 
   parenth's directly after the classname
 - 'pass' has similar meaning to 'abstract' in .NET
 - the order-of-inheritance in the parenths is the 
   canon for resolving multi-inheritance 
 
 #handling multi inheritance
 class Proot:
     attr = 0
 class Pof_00(Proot):
     attr = 1
 class Pof_01(Proot):
     attr = 2
 class Pof_10(Pof_10, Pof_00):  #the order here is what matters
     pass
 myP = Pof_10()
 print(myP.attr) #results in '2'
 
 class Pof_11(Pof_00, Pof_10):
     pass
 myP2 = Pof_11()
 print(myP2.attr) #results in '1'
----

----
Object Operator Overloads
 - builtin ops are provided by specially named methods
 - are like methods present on all objects
 - all start\end with double-underscore
 
 - sort of like .NET object activator, not typically used
 - py doesn't require the 'new' keyword for instantiation since
   simply call "myVar = MyType()" does this.
 __new__(cls [, args]*)
 
 - this is an object ctor 
 __init__(self [,args]*)
 
 - this is called prior to GC
 __del__(self)
 
 - this my be implement to have the object returned a py code
   as a string literal 
 __repr__(self)
 
 - this is the classic ToString() override
 __str__(self)
 
 - this is neat in that the string format is returned
 - the string construct is the format used in str.format
 __format__(self, formatspec)
  
 - this seems to be a kind of bin serialization builtin
 - returns the object as a types string representation
 __bytes__(self)
 
 - this is just like .NET's GetHashCode() and is used
   for equality ops
 __hash__(self)  
 
 - strange propositional testing of instances...
 - not sure what this is used for, returns as expected 'True' or 'False'
 __bool__(self)
 
 - text has this as "when an instance is called like a function"
 __call__(self [,arg]*)

 - classic operator overloads
 - meaning is obvious, similar to PowerShell's op names
 __lt__(self,other)
 __le__(self,other)
 __eq__(self,other)
 __ne__(self,other)
 __gt__(self,other)
 __ge__(self,other)
 
 - calling "dir(myInstance)" returns an array strings of the 
   instance members
 - this allows for more control over the builtin
 __dir__(self)
----

----
Collection Operator Overloads
 - these are not present on every kind of object
 - are for use of collection-like object types
 
 __len__(self)
 __contains__(self, item)
 
 - this is similar to .NET's GetEnumerator
 __iter__(self) 
 
 - this is like calles on the enumerator.Next()
 __next__(self)
 
 - for index collection access
 __getitem__(self, key)
 __setitem__(self, key)
 __delitem__(self, key)

----

----
Arithmetic & Bitwise Operator Overloads
 - there are variants of these which 
   have the same signature, but are prefixed
   by an 'r' and are called when the 'other'
   operand doesn't have an implementation for 
   these builtins
 - it is also possiable to overload the compound
   assignment operators of these, in such a case
   the builtin is prefixed with an 'i'
   
 __add__(self, other)         # a + b
 __sub__(self, other)         # a - b
 __mul__(self, other)         # a * b
 __truediv__(self, other)     # a / b
 __floordiv__(self, other)    # a // b
 __mod__(self, other)         # a % b
 __divmod__(self, other)      # divmod(a, b)
 __pow__(self, other)         # a ** b
 
 __lshift__(self, other)      # a << b
 __rshift__(self, other)      # a >> b
 __and__(self, other)         # a & b
 __xor__(self, other)         # a ^ b
 __or__(self, other)          # a | b
 
 - these a single operand operators
 - there are also builtins for complex, int, float
   round and index
 __neg__(self)                # -a
 __pos__(self)                # +a
 __invert__(self)             # ~a

----

----
Builtin Global functions
 - a select list, seem most useful from exp.
   and not otherwise listed
 - for eval'ing a single expression
 eval(strExpr [, globals [, locals]]) 
 
 - for eval'ing multiple statements
 exec(strStmts [, globals [, locals]])
 
 - returns a dictionary of all types in scope 
   at the top of the runtime
 globals()
 
 - the opposite of the above, returns a like dict
 locals()
 
 - a kind of reflection for testing
 - 'object' is the type, not an instance
 - 'name' is a string
 hasattr(object, name)
 
 - text has that there is a "built-in help system"
 help([object])
 
 - is the memory location, takes instances and types
 id(object)
 
 - like id but is used by dictionaries for lookups
 - appears to work with both types and instances
 hash(object)
 
 - for console user input
 input([prompt])
 
 - for testing of types
 class Proot:
     attr = 1
 class Pnext(Proot):
     pass
 myP = Pnext()
 type(myP) is Proot      # is false
 type(myP) is Pnext      # is true
 isinstance(myP, Proot)  # is true
 isinstance(myP, Pnext)  # is true
 
 - ctor for a kind of root object of all types (py 3.X)
 object()
 
 - for calling the parent's implementation of the method 
   (being called from within the override)
 - the arg params are implicitly passed to the parent
 super() 
----

----
IO Util
 os.path.exists(path)
 os.path.abspath(path)
 os.path.basename(path)
 os.path.dirname(path)
 os.path.getsize(path)
 os.path.isabs(path)
 os.path.isfile(path)
 os.path.isdir(path)
 os.path.join(path1 [,path2]*)
 os.path.split(path) #splits dir from filename
 os.path.splittext(path) #splits filename from extension
----

----
Regex Module
 - module named 're'

 re.escape(string) #esc the string for regex matching 
 mobj = re.match(pattern, string [,flags])
 mobj = re.search(pattern, string [,flags])

 pobj = re.compile(pattern [,flags])
 
---- 

----
Top Level Builtin Exception types
 Exception 
 ArithmeticError
 BufferError
 LookupError
 LookupError
 OSError  - for wrapping a lower OS related error
 WindowsError - extends OSError, for windows only
----
 
----
Variable Names
 - std C-style rules

 - keywords
and
as
assert
break
class
continue
def
del
elif
else
except
False
finally
for
from
global
if
import
in
is
lambda
None
nonlocal
not
or
pass
raise
return
True
try
while
with
yield
----